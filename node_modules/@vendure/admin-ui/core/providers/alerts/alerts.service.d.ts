import { Injector } from '@angular/core';
import { Observable } from 'rxjs';
import { Permission } from '../../common/generated-types';
import { DataService } from '../../data/providers/data.service';
import { ModalService } from '../modal/modal.service';
import { NotificationService } from '../notification/notification.service';
import { PermissionsService } from '../permissions/permissions.service';
import * as i0 from "@angular/core";
/**
 * @description
 * The context object which is passed to the `check`, `isAlert`, `label` and `action` functions of an
 * {@link AlertConfig} object.
 *
 * @since 2.2.0
 * @docsCategory alerts
 */
export interface AlertContext {
    /**
     * @description
     * The Angular [Injector](https://angular.dev/api/core/Injector) which can be used to get instances
     * of services and other providers available in the application.
     */
    injector: Injector;
    /**
     * @description
     * The [DataService](/reference/admin-ui-api/services/data-service), which provides methods for querying the
     * server-side data.
     */
    dataService: DataService;
    /**
     * @description
     * The [NotificationService](/reference/admin-ui-api/services/notification-service), which provides methods for
     * displaying notifications to the user.
     */
    notificationService: NotificationService;
    /**
     * @description
     * The [ModalService](/reference/admin-ui-api/services/modal-service), which provides methods for
     * opening modal dialogs.
     */
    modalService: ModalService;
}
/**
 * @description
 * A configuration object for an Admin UI alert.
 *
 * @since 2.2.0
 * @docsCategory alerts
 */
export interface AlertConfig<T = any> {
    /**
     * @description
     * A unique identifier for the alert.
     */
    id: string;
    /**
     * @description
     * A function which is gets the data used to determine whether the alert should be shown.
     * Typically, this function will query the server or some other remote data source.
     *
     * This function will be called once when the Admin UI app bootstraps, and can be also
     * set to run at regular intervals by setting the `recheckIntervalMs` property.
     */
    check: (context: AlertContext) => T | Promise<T> | Observable<T>;
    /**
     * @description
     * A function which returns an Observable which is used to determine when to re-run the `check`
     * function. Whenever the observable emits, the `check` function will be called again.
     *
     * A basic time-interval-based recheck can be achieved by using the `interval` function from RxJS.
     *
     * @example
     * ```ts
     * import { interval } from 'rxjs';
     *
     * // ...
     * recheck: () => interval(60_000)
     * ```
     *
     * If this is not set, the `check` function will only be called once when the Admin UI app bootstraps.
     *
     * @default undefined
     */
    recheck?: (context: AlertContext) => Observable<any>;
    /**
     * @description
     * A function which determines whether the alert should be shown based on the data returned by the `check`
     * function.
     */
    isAlert: (data: T, context: AlertContext) => boolean;
    /**
     * @description
     * A function which is called when the alert is clicked in the Admin UI.
     */
    action: (data: T, context: AlertContext) => void;
    /**
     * @description
     * A function which returns the text used in the UI to describe the alert.
     */
    label: (data: T, context: AlertContext) => {
        text: string;
        translationVars?: {
            [key: string]: string | number;
        };
    };
    /**
     * @description
     * A list of permissions which the current Administrator must have in order. If the current
     * Administrator does not have these permissions, none of the other alert functions will be called.
     */
    requiredPermissions?: Permission[];
}
export interface ActiveAlert {
    id: string;
    runAction: () => void;
    hasRun: boolean;
    label: {
        text: string;
        translationVars?: {
            [key: string]: string | number;
        };
    };
}
export declare class Alert<T> {
    private config;
    private context;
    activeAlert$: Observable<ActiveAlert | undefined>;
    private hasRun$;
    private data$;
    private readonly subscription;
    constructor(config: AlertConfig<T>, context: AlertContext);
    get id(): string;
    runCheck(): void;
    destroy(): void;
}
export declare class AlertsService {
    private permissionsService;
    private injector;
    private dataService;
    private notificationService;
    private modalService;
    activeAlerts$: Observable<ActiveAlert[]>;
    private alertsMap;
    private configUpdated;
    constructor(permissionsService: PermissionsService, injector: Injector, dataService: DataService, notificationService: NotificationService, modalService: ModalService);
    configureAlert<T>(config: AlertConfig<T>): void;
    hasSufficientPermissions(permissions?: Permission[]): Observable<boolean>;
    refresh(id?: string): void;
    clearAlerts(): void;
    protected createContext(): AlertContext;
    static ɵfac: i0.ɵɵFactoryDeclaration<AlertsService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<AlertsService>;
}
