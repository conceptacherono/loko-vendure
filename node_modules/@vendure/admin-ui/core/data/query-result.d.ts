import { Apollo, QueryRef } from 'apollo-angular';
import { Observable } from 'rxjs';
import { CustomFieldConfig } from '../common/generated-types';
/**
 * @description
 * This class wraps the Apollo Angular QueryRef object and exposes some getters
 * for convenience.
 *
 * @docsCategory services
 * @docsPage DataService
 */
export declare class QueryResult<T, V extends Record<string, any> = Record<string, any>> {
    private queryRef;
    private apollo;
    private customFieldMap;
    constructor(queryRef: QueryRef<T, V>, apollo: Apollo, customFieldMap: Map<string, CustomFieldConfig[]>);
    /**
     * Causes any subscriptions to the QueryRef to complete, via the use
     * of the `takeUntil` operator.
     */
    private completed$;
    /**
     * The subscription to the current QueryRef.valueChanges Observable.
     * This is stored so that it can be unsubscribed from when the QueryRef
     * changes.
     */
    private valueChangesSubscription;
    /**
     * This Subject is used to emit new values from the QueryRef.valueChanges Observable.
     * We use this rather than directly subscribing to the QueryRef.valueChanges Observable
     * so that we are able to change the QueryRef and re-subscribe when necessary.
     */
    private valueChangeSubject;
    /**
     * We keep track of the QueryRefs which have been subscribed to so that we can avoid
     * re-subscribing to the same QueryRef multiple times.
     */
    private queryRefSubscribed;
    /**
     * We store a reference to the last query so that we can compare it with the next query
     * and avoid re-fetching the same query multiple times. This is applicable to the code
     * paths that actually change the query, i.e. refetchOnCustomFieldsChange().
     */
    private lastQuery;
    /**
     * @description
     * Re-fetch this query whenever the active Channel changes.
     */
    refetchOnChannelChange(): QueryResult<T, V>;
    /**
     * @description
     * Re-fetch this query whenever the custom fields change, updating the query to include the
     * specified custom fields.
     *
     * @since 3.0.4
     */
    refetchOnCustomFieldsChange(customFieldsToInclude$: Observable<string[]>): QueryResult<T, V>;
    /**
     * @description
     * Returns an Observable which emits a single result and then completes.
     */
    get single$(): Observable<T>;
    /**
     * @description
     * Returns an Observable which emits until unsubscribed.
     */
    get stream$(): Observable<T>;
    get ref(): QueryRef<T, V>;
    /**
     * @description
     * Returns a single-result Observable after applying the map function.
     */
    mapSingle<R>(mapFn: (item: T) => R): Observable<R>;
    /**
     * @description
     * Returns a multiple-result Observable after applying the map function.
     */
    mapStream<R>(mapFn: (item: T) => R): Observable<R>;
    /**
     * @description
     * Signals to the internal Observable subscriptions that they should complete.
     */
    destroy(): void;
    /**
     * @description
     * Returns an Observable which emits the current value of the QueryRef.valueChanges Observable.
     *
     * We wrap the valueChanges Observable in a new Observable so that we can have a lazy
     * evaluation of the valueChanges Observable. That is, we only fire the HTTP request when
     * the returned Observable is subscribed to.
     */
    private get currentQueryRefValueChanges();
    /**
     * @description
     * Subscribes to the valueChanges Observable of the given QueryRef, and stores the subscription
     * so that it can be unsubscribed from when the QueryRef changes.
     */
    private subscribeToQueryRef;
}
