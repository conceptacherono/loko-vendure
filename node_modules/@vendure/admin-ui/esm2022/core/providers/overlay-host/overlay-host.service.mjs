import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * The OverlayHostService is used to get a reference to the ViewConainerRef of the
 * OverlayHost component, so that other components may insert components & elements
 * into the DOM at that point.
 */
export class OverlayHostService {
    constructor() {
        this.promiseResolveFns = [];
    }
    /**
     * Used to pass in the ViewContainerRed from the OverlayHost component.
     * Should not be used by any other component.
     */
    registerHostView(viewContainerRef) {
        this.hostView = viewContainerRef;
        if (0 < this.promiseResolveFns.length) {
            this.resolveHostView();
        }
    }
    /**
     * Returns a promise which resolves to the ViewContainerRef of the OverlayHost
     * component. This can then be used to insert components and elements into the
     * DOM at that point.
     */
    getHostView() {
        return new Promise((resolve) => {
            this.promiseResolveFns.push(resolve);
            if (this.hostView !== undefined) {
                this.resolveHostView();
            }
        });
    }
    resolveHostView() {
        this.promiseResolveFns.forEach(resolve => resolve(this.hostView));
        this.promiseResolveFns = [];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: OverlayHostService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: OverlayHostService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: OverlayHostService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcmxheS1ob3N0LnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3Byb3ZpZGVycy9vdmVybGF5LWhvc3Qvb3ZlcmxheS1ob3N0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBb0IsTUFBTSxlQUFlLENBQUM7O0FBRTdEOzs7O0dBSUc7QUFJSCxNQUFNLE9BQU8sa0JBQWtCO0lBSC9CO1FBS1ksc0JBQWlCLEdBQWlDLEVBQUUsQ0FBQztLQStCaEU7SUE3Qkc7OztPQUdHO0lBQ0gsZ0JBQWdCLENBQUMsZ0JBQWtDO1FBQy9DLElBQUksQ0FBQyxRQUFRLEdBQUcsZ0JBQWdCLENBQUM7UUFDakMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUMzQixDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxXQUFXO1FBQ1AsT0FBTyxJQUFJLE9BQU8sQ0FBQyxDQUFDLE9BQThCLEVBQUUsRUFBRTtZQUNsRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3JDLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxTQUFTLEVBQUUsQ0FBQztnQkFDOUIsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQzNCLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFTyxlQUFlO1FBQ25CLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDbEUsSUFBSSxDQUFDLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztJQUNoQyxDQUFDOzhHQWhDUSxrQkFBa0I7a0hBQWxCLGtCQUFrQixjQUZmLE1BQU07OzJGQUVULGtCQUFrQjtrQkFIOUIsVUFBVTttQkFBQztvQkFDUixVQUFVLEVBQUUsTUFBTTtpQkFDckIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG4vKipcclxuICogVGhlIE92ZXJsYXlIb3N0U2VydmljZSBpcyB1c2VkIHRvIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgVmlld0NvbmFpbmVyUmVmIG9mIHRoZVxyXG4gKiBPdmVybGF5SG9zdCBjb21wb25lbnQsIHNvIHRoYXQgb3RoZXIgY29tcG9uZW50cyBtYXkgaW5zZXJ0IGNvbXBvbmVudHMgJiBlbGVtZW50c1xyXG4gKiBpbnRvIHRoZSBET00gYXQgdGhhdCBwb2ludC5cclxuICovXHJcbkBJbmplY3RhYmxlKHtcclxuICAgIHByb3ZpZGVkSW46ICdyb290JyxcclxufSlcclxuZXhwb3J0IGNsYXNzIE92ZXJsYXlIb3N0U2VydmljZSB7XHJcbiAgICBwcml2YXRlIGhvc3RWaWV3OiBWaWV3Q29udGFpbmVyUmVmO1xyXG4gICAgcHJpdmF0ZSBwcm9taXNlUmVzb2x2ZUZuczogQXJyYXk8KHJlc3VsdDogYW55KSA9PiB2b2lkPiA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBwYXNzIGluIHRoZSBWaWV3Q29udGFpbmVyUmVkIGZyb20gdGhlIE92ZXJsYXlIb3N0IGNvbXBvbmVudC5cclxuICAgICAqIFNob3VsZCBub3QgYmUgdXNlZCBieSBhbnkgb3RoZXIgY29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICByZWdpc3Rlckhvc3RWaWV3KHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmhvc3RWaWV3ID0gdmlld0NvbnRhaW5lclJlZjtcclxuICAgICAgICBpZiAoMCA8IHRoaXMucHJvbWlzZVJlc29sdmVGbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZUhvc3RWaWV3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIFZpZXdDb250YWluZXJSZWYgb2YgdGhlIE92ZXJsYXlIb3N0XHJcbiAgICAgKiBjb21wb25lbnQuIFRoaXMgY2FuIHRoZW4gYmUgdXNlZCB0byBpbnNlcnQgY29tcG9uZW50cyBhbmQgZWxlbWVudHMgaW50byB0aGVcclxuICAgICAqIERPTSBhdCB0aGF0IHBvaW50LlxyXG4gICAgICovXHJcbiAgICBnZXRIb3N0VmlldygpOiBQcm9taXNlPFZpZXdDb250YWluZXJSZWY+IHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmU6IChyZXN1bHQ6IGFueSkgPT4gdm9pZCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnByb21pc2VSZXNvbHZlRm5zLnB1c2gocmVzb2x2ZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhvc3RWaWV3ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUhvc3RWaWV3KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlc29sdmVIb3N0VmlldygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnByb21pc2VSZXNvbHZlRm5zLmZvckVhY2gocmVzb2x2ZSA9PiByZXNvbHZlKHRoaXMuaG9zdFZpZXcpKTtcclxuICAgICAgICB0aGlzLnByb21pc2VSZXNvbHZlRm5zID0gW107XHJcbiAgICB9XHJcbn1cclxuIl19