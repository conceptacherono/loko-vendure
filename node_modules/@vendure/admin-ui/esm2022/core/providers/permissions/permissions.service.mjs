import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import * as i0 from "@angular/core";
/**
 * @description
 * This service is used internally to power components & logic that are dependent on knowing the
 * current user's permissions in the currently-active channel.
 */
export class PermissionsService {
    constructor() {
        this.currentUserPermissions = [];
        this._currentUserPermissions$ = new BehaviorSubject([]);
        this.currentUserPermissions$ = this._currentUserPermissions$.asObservable();
    }
    /**
     * @description
     * This is called whenever:
     * - the user logs in
     * - the active channel changes
     *
     * Since active user validation occurs as part of the main auth guard, we can be assured
     * that if the user is logged in, then this method will be called with the user's permissions
     * before any other components are rendered lower down in the component tree.
     */
    setCurrentUserPermissions(permissions) {
        this.currentUserPermissions = permissions;
        this._currentUserPermissions$.next(permissions);
    }
    userHasPermissions(requiredPermissions) {
        for (const perm of requiredPermissions) {
            if (this.currentUserPermissions.includes(perm)) {
                return true;
            }
        }
        return false;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: PermissionsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: PermissionsService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: PermissionsService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVybWlzc2lvbnMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29yZS9zcmMvcHJvdmlkZXJzL3Blcm1pc3Npb25zL3Blcm1pc3Npb25zLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sTUFBTSxDQUFDOztBQUd2Qzs7OztHQUlHO0FBSUgsTUFBTSxPQUFPLGtCQUFrQjtJQUgvQjtRQUlZLDJCQUFzQixHQUFhLEVBQUUsQ0FBQztRQUN0Qyw2QkFBd0IsR0FBRyxJQUFJLGVBQWUsQ0FBVyxFQUFFLENBQUMsQ0FBQztRQUNyRSw0QkFBdUIsR0FBRyxJQUFJLENBQUMsd0JBQXdCLENBQUMsWUFBWSxFQUFFLENBQUM7S0F5QjFFO0lBdkJHOzs7Ozs7Ozs7T0FTRztJQUNILHlCQUF5QixDQUFDLFdBQXFCO1FBQzNDLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxXQUFXLENBQUM7UUFDMUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQsa0JBQWtCLENBQUMsbUJBQStDO1FBQzlELEtBQUssTUFBTSxJQUFJLElBQUksbUJBQW1CLEVBQUUsQ0FBQztZQUNyQyxJQUFJLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDN0MsT0FBTyxJQUFJLENBQUM7WUFDaEIsQ0FBQztRQUNMLENBQUM7UUFDRCxPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDOzhHQTNCUSxrQkFBa0I7a0hBQWxCLGtCQUFrQixjQUZmLE1BQU07OzJGQUVULGtCQUFrQjtrQkFIOUIsVUFBVTttQkFBQztvQkFDUixVQUFVLEVBQUUsTUFBTTtpQkFDckIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBQZXJtaXNzaW9uIH0gZnJvbSAnLi4vLi4vY29tbW9uL2dlbmVyYXRlZC10eXBlcyc7XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFRoaXMgc2VydmljZSBpcyB1c2VkIGludGVybmFsbHkgdG8gcG93ZXIgY29tcG9uZW50cyAmIGxvZ2ljIHRoYXQgYXJlIGRlcGVuZGVudCBvbiBrbm93aW5nIHRoZVxyXG4gKiBjdXJyZW50IHVzZXIncyBwZXJtaXNzaW9ucyBpbiB0aGUgY3VycmVudGx5LWFjdGl2ZSBjaGFubmVsLlxyXG4gKi9cclxuQEluamVjdGFibGUoe1xyXG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbnNTZXJ2aWNlIHtcclxuICAgIHByaXZhdGUgY3VycmVudFVzZXJQZXJtaXNzaW9uczogc3RyaW5nW10gPSBbXTtcclxuICAgIHByaXZhdGUgX2N1cnJlbnRVc2VyUGVybWlzc2lvbnMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxzdHJpbmdbXT4oW10pO1xyXG4gICAgY3VycmVudFVzZXJQZXJtaXNzaW9ucyQgPSB0aGlzLl9jdXJyZW50VXNlclBlcm1pc3Npb25zJC5hc09ic2VydmFibGUoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXNjcmlwdGlvblxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbmV2ZXI6XHJcbiAgICAgKiAtIHRoZSB1c2VyIGxvZ3MgaW5cclxuICAgICAqIC0gdGhlIGFjdGl2ZSBjaGFubmVsIGNoYW5nZXNcclxuICAgICAqXHJcbiAgICAgKiBTaW5jZSBhY3RpdmUgdXNlciB2YWxpZGF0aW9uIG9jY3VycyBhcyBwYXJ0IG9mIHRoZSBtYWluIGF1dGggZ3VhcmQsIHdlIGNhbiBiZSBhc3N1cmVkXHJcbiAgICAgKiB0aGF0IGlmIHRoZSB1c2VyIGlzIGxvZ2dlZCBpbiwgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1c2VyJ3MgcGVybWlzc2lvbnNcclxuICAgICAqIGJlZm9yZSBhbnkgb3RoZXIgY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgbG93ZXIgZG93biBpbiB0aGUgY29tcG9uZW50IHRyZWUuXHJcbiAgICAgKi9cclxuICAgIHNldEN1cnJlbnRVc2VyUGVybWlzc2lvbnMocGVybWlzc2lvbnM6IHN0cmluZ1tdKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VXNlclBlcm1pc3Npb25zID0gcGVybWlzc2lvbnM7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFVzZXJQZXJtaXNzaW9ucyQubmV4dChwZXJtaXNzaW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgdXNlckhhc1Blcm1pc3Npb25zKHJlcXVpcmVkUGVybWlzc2lvbnM6IEFycmF5PHN0cmluZyB8IFBlcm1pc3Npb24+KTogYm9vbGVhbiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwZXJtIG9mIHJlcXVpcmVkUGVybWlzc2lvbnMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFVzZXJQZXJtaXNzaW9ucy5pbmNsdWRlcyhwZXJtKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==