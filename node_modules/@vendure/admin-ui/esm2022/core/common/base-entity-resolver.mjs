import { ActivationStart, } from '@angular/router';
import { notNullOrUndefined } from '@vendure/common/lib/shared-utils';
import { of } from 'rxjs';
import { filter, map, shareReplay, take, takeUntil } from 'rxjs/operators';
export function createResolveData(resolver) {
    return {
        entity: resolver,
    };
}
/**
 * @description
 * A base resolver for an entity detail route. Resolves to an observable of the given entity, or a "blank"
 * version if the route id equals "create". Should be used together with details views which extend the
 * {@link BaseDetailComponent}.
 *
 * @example
 * ```ts
 * \@Injectable({
 *   providedIn: 'root',
 * })
 * export class MyEntityResolver extends BaseEntityResolver<MyEntityFragment> {
 *   constructor(router: Router, dataService: DataService) {
 *     super(
 *       router,
 *       {
 *         __typename: 'MyEntity',
 *         id: '',
 *         createdAt: '',
 *         updatedAt: '',
 *         name: '',
 *       },
 *       id => dataService.query(GET_MY_ENTITY, { id }).mapStream(data => data.myEntity),
 *     );
 *   }
 * }
 * ```
 *
 * @docsCategory list-detail-views
 */
export class BaseEntityResolver {
    constructor(router, emptyEntity, entityStream) {
        this.router = router;
        this.emptyEntity = emptyEntity;
        this.entityStream = entityStream;
    }
    /** @internal */
    resolve(route, state) {
        const id = route.paramMap.get('id');
        // Complete the entity stream upon navigating away
        const navigateAway$ = this.router.events.pipe(filter(event => event instanceof ActivationStart));
        if (id === 'create') {
            return of(of(this.emptyEntity));
        }
        else {
            const stream = this.entityStream(id || '').pipe(takeUntil(navigateAway$), filter(notNullOrUndefined), shareReplay(1));
            return stream.pipe(take(1), map(() => stream));
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1lbnRpdHktcmVzb2x2ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL2NvbW1vbi9iYXNlLWVudGl0eS1yZXNvbHZlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUgsZUFBZSxHQUlsQixNQUFNLGlCQUFpQixDQUFDO0FBRXpCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3RFLE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUUsV0FBVyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQU0zRSxNQUFNLFVBQVUsaUJBQWlCLENBQzdCLFFBQWlCO0lBRWpCLE9BQU87UUFDSCxNQUFNLEVBQUUsUUFBUTtLQUNuQixDQUFDO0FBQ04sQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTZCRztBQUNILE1BQU0sT0FBTyxrQkFBa0I7SUFDM0IsWUFDYyxNQUFjLEVBQ1AsV0FBYyxFQUN2QixZQUE4RDtRQUY1RCxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ1AsZ0JBQVcsR0FBWCxXQUFXLENBQUc7UUFDdkIsaUJBQVksR0FBWixZQUFZLENBQWtEO0lBQ3ZFLENBQUM7SUFFSixnQkFBZ0I7SUFDaEIsT0FBTyxDQUFDLEtBQTZCLEVBQUUsS0FBMEI7UUFDN0QsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFcEMsa0RBQWtEO1FBQ2xELE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLFlBQVksZUFBZSxDQUFDLENBQUMsQ0FBQztRQUVqRyxJQUFJLEVBQUUsS0FBSyxRQUFRLEVBQUUsQ0FBQztZQUNsQixPQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7UUFDcEMsQ0FBQzthQUFNLENBQUM7WUFDSixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQzNDLFNBQVMsQ0FBQyxhQUFhLENBQUMsRUFDeEIsTUFBTSxDQUFDLGtCQUFrQixDQUFDLEVBQzFCLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FDakIsQ0FBQztZQUVGLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FDZCxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQ1AsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUNwQixDQUFDO1FBQ04sQ0FBQztJQUNMLENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgICBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LFxyXG4gICAgQWN0aXZhdGlvblN0YXJ0LFxyXG4gICAgUmVzb2x2ZURhdGEsXHJcbiAgICBSb3V0ZXIsXHJcbiAgICBSb3V0ZXJTdGF0ZVNuYXBzaG90LFxyXG59IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XHJcbmltcG9ydCB7IFR5cGUgfSBmcm9tICdAdmVuZHVyZS9jb21tb24vbGliL3NoYXJlZC10eXBlcyc7XHJcbmltcG9ydCB7IG5vdE51bGxPclVuZGVmaW5lZCB9IGZyb20gJ0B2ZW5kdXJlL2NvbW1vbi9saWIvc2hhcmVkLXV0aWxzJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZmlsdGVyLCBtYXAsIHNoYXJlUmVwbGF5LCB0YWtlLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVudGl0eVJlc29sdmVEYXRhPFI+IGV4dGVuZHMgUmVzb2x2ZURhdGEge1xyXG4gICAgZW50aXR5OiBUeXBlPEJhc2VFbnRpdHlSZXNvbHZlcjxSPj47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZXNvbHZlRGF0YTxUIGV4dGVuZHMgQmFzZUVudGl0eVJlc29sdmVyPFI+LCBSPihcclxuICAgIHJlc29sdmVyOiBUeXBlPFQ+LFxyXG4pOiBFbnRpdHlSZXNvbHZlRGF0YTxSPiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGVudGl0eTogcmVzb2x2ZXIsXHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEEgYmFzZSByZXNvbHZlciBmb3IgYW4gZW50aXR5IGRldGFpbCByb3V0ZS4gUmVzb2x2ZXMgdG8gYW4gb2JzZXJ2YWJsZSBvZiB0aGUgZ2l2ZW4gZW50aXR5LCBvciBhIFwiYmxhbmtcIlxyXG4gKiB2ZXJzaW9uIGlmIHRoZSByb3V0ZSBpZCBlcXVhbHMgXCJjcmVhdGVcIi4gU2hvdWxkIGJlIHVzZWQgdG9nZXRoZXIgd2l0aCBkZXRhaWxzIHZpZXdzIHdoaWNoIGV4dGVuZCB0aGVcclxuICoge0BsaW5rIEJhc2VEZXRhaWxDb21wb25lbnR9LlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBgYGB0c1xyXG4gKiBcXEBJbmplY3RhYmxlKHtcclxuICogICBwcm92aWRlZEluOiAncm9vdCcsXHJcbiAqIH0pXHJcbiAqIGV4cG9ydCBjbGFzcyBNeUVudGl0eVJlc29sdmVyIGV4dGVuZHMgQmFzZUVudGl0eVJlc29sdmVyPE15RW50aXR5RnJhZ21lbnQ+IHtcclxuICogICBjb25zdHJ1Y3Rvcihyb3V0ZXI6IFJvdXRlciwgZGF0YVNlcnZpY2U6IERhdGFTZXJ2aWNlKSB7XHJcbiAqICAgICBzdXBlcihcclxuICogICAgICAgcm91dGVyLFxyXG4gKiAgICAgICB7XHJcbiAqICAgICAgICAgX190eXBlbmFtZTogJ015RW50aXR5JyxcclxuICogICAgICAgICBpZDogJycsXHJcbiAqICAgICAgICAgY3JlYXRlZEF0OiAnJyxcclxuICogICAgICAgICB1cGRhdGVkQXQ6ICcnLFxyXG4gKiAgICAgICAgIG5hbWU6ICcnLFxyXG4gKiAgICAgICB9LFxyXG4gKiAgICAgICBpZCA9PiBkYXRhU2VydmljZS5xdWVyeShHRVRfTVlfRU5USVRZLCB7IGlkIH0pLm1hcFN0cmVhbShkYXRhID0+IGRhdGEubXlFbnRpdHkpLFxyXG4gKiAgICAgKTtcclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBkb2NzQ2F0ZWdvcnkgbGlzdC1kZXRhaWwtdmlld3NcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCYXNlRW50aXR5UmVzb2x2ZXI8VD4ge1xyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgcHJvdGVjdGVkIHJvdXRlcjogUm91dGVyLFxyXG4gICAgICAgIHByaXZhdGUgcmVhZG9ubHkgZW1wdHlFbnRpdHk6IFQsXHJcbiAgICAgICAgcHJpdmF0ZSBlbnRpdHlTdHJlYW06IChpZDogc3RyaW5nKSA9PiBPYnNlcnZhYmxlPFQgfCBudWxsIHwgdW5kZWZpbmVkPixcclxuICAgICkge31cclxuXHJcbiAgICAvKiogQGludGVybmFsICovXHJcbiAgICByZXNvbHZlKHJvdXRlOiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCBzdGF0ZTogUm91dGVyU3RhdGVTbmFwc2hvdCk6IE9ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj4ge1xyXG4gICAgICAgIGNvbnN0IGlkID0gcm91dGUucGFyYW1NYXAuZ2V0KCdpZCcpO1xyXG5cclxuICAgICAgICAvLyBDb21wbGV0ZSB0aGUgZW50aXR5IHN0cmVhbSB1cG9uIG5hdmlnYXRpbmcgYXdheVxyXG4gICAgICAgIGNvbnN0IG5hdmlnYXRlQXdheSQgPSB0aGlzLnJvdXRlci5ldmVudHMucGlwZShmaWx0ZXIoZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBBY3RpdmF0aW9uU3RhcnQpKTtcclxuXHJcbiAgICAgICAgaWYgKGlkID09PSAnY3JlYXRlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gb2Yob2YodGhpcy5lbXB0eUVudGl0eSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuZW50aXR5U3RyZWFtKGlkIHx8ICcnKS5waXBlKFxyXG4gICAgICAgICAgICAgICAgdGFrZVVudGlsKG5hdmlnYXRlQXdheSQpLFxyXG4gICAgICAgICAgICAgICAgZmlsdGVyKG5vdE51bGxPclVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgICAgICBzaGFyZVJlcGxheSgxKSxcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW0ucGlwZShcclxuICAgICAgICAgICAgICAgIHRha2UoMSksXHJcbiAgICAgICAgICAgICAgICBtYXAoKCkgPT4gc3RyZWFtKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl19