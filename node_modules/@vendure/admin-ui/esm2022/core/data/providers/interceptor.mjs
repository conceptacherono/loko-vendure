import { HttpErrorResponse, HttpResponse, } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { marker as _ } from '@biesbjerg/ngx-translate-extract-marker';
import { DEFAULT_AUTH_TOKEN_HEADER_KEY } from '@vendure/common/lib/shared-constants';
import { switchMap, tap } from 'rxjs/operators';
import { getAppConfig } from '../../app.config';
import { NotificationService } from '../../providers/notification/notification.service';
import * as i0 from "@angular/core";
import * as i1 from "./data.service";
import * as i2 from "../../providers/auth/auth.service";
import * as i3 from "@angular/router";
import * as i4 from "../../providers/local-storage/local-storage.service";
export const AUTH_REDIRECT_PARAM = 'redirectTo';
/**
 * The default interceptor examines all HTTP requests & responses and automatically updates the requesting state
 * and shows error notifications.
 */
export class DefaultInterceptor {
    constructor(dataService, injector, authService, router, localStorageService) {
        this.dataService = dataService;
        this.injector = injector;
        this.authService = authService;
        this.router = router;
        this.localStorageService = localStorageService;
        this.tokenMethod = 'cookie';
        this.tokenMethod = getAppConfig().tokenMethod;
        this.authTokenHeaderKey = getAppConfig().authTokenHeaderKey || DEFAULT_AUTH_TOKEN_HEADER_KEY;
    }
    intercept(req, next) {
        this.dataService.client.startRequest().subscribe();
        return this.dataService.client.uiState().single$.pipe(switchMap(({ uiState }) => {
            const request = req.clone({
                setParams: {
                    languageCode: uiState?.contentLanguage ?? '',
                },
            });
            return next.handle(request);
        }), tap(event => {
            if (event instanceof HttpResponse) {
                this.checkForAuthToken(event);
                this.notifyOnError(event);
                this.dataService.client.completeRequest().subscribe();
            }
        }, err => {
            if (err instanceof HttpErrorResponse) {
                this.notifyOnError(err);
                this.dataService.client.completeRequest().subscribe();
            }
            else {
                this.displayErrorNotification(err.message);
            }
        }));
    }
    notifyOnError(response) {
        if (response instanceof HttpErrorResponse) {
            if (response.status === 0) {
                const { apiHost, apiPort } = getAppConfig();
                this.displayErrorNotification(_(`error.could-not-connect-to-server`), {
                    url: `${apiHost}:${apiPort}`,
                });
            }
            else if (response.status === 503 && response.url?.endsWith('/health')) {
                this.displayErrorNotification(_(`error.health-check-failed`));
            }
            else {
                this.displayErrorNotification(this.extractErrorFromHttpResponse(response));
            }
        }
        else {
            // GraphQL errors still return 200 OK responses, but have the actual error message
            // inside the body of the response.
            const graphQLErrors = response.body.errors;
            if (graphQLErrors && Array.isArray(graphQLErrors)) {
                const firstCode = graphQLErrors[0]?.extensions?.code;
                if (firstCode === 'FORBIDDEN') {
                    this.authService.logOut().subscribe(() => {
                        const { loginUrl } = getAppConfig();
                        // If there is a `loginUrl` which is external to the AdminUI, redirect to it (with no query parameters)
                        if (loginUrl && !this.areUrlsOnSameOrigin(loginUrl, window.location.origin)) {
                            window.location.href = loginUrl;
                            return;
                        }
                        // Else, we build the login path from the login url if one is provided or fallback to `/login`
                        const loginPath = loginUrl ? this.getPathFromLoginUrl(loginUrl) : '/login';
                        if (!window.location.pathname.includes(loginPath)) {
                            const path = graphQLErrors[0].path.join(' > ');
                            this.displayErrorNotification(_(`error.403-forbidden`), { path });
                        }
                        // Navigate to the `loginPath` route by ensuring the query param in charge of the redirection is provided
                        this.router.navigate([loginPath], {
                            queryParams: {
                                [AUTH_REDIRECT_PARAM]: btoa(this.router.url),
                            },
                        });
                    });
                }
                else if (firstCode === 'CHANNEL_NOT_FOUND') {
                    const message = graphQLErrors.map(err => err.message).join('\n');
                    this.displayErrorNotification(message);
                    this.localStorageService.remove('activeChannelToken');
                }
                else {
                    const message = graphQLErrors.map(err => err.message).join('\n');
                    this.displayErrorNotification(message);
                }
            }
        }
    }
    extractErrorFromHttpResponse(response) {
        const errors = response.error.errors;
        if (Array.isArray(errors)) {
            return errors.map(e => e.message).join('\n');
        }
        else {
            return response.message;
        }
    }
    /**
     * We need to lazily inject the NotificationService since it depends on the I18nService which
     * eventually depends on the HttpClient (used to load messages from json files). If we were to
     * directly inject NotificationService into the constructor, we get a cyclic dependency.
     */
    displayErrorNotification(message, vars) {
        const notificationService = this.injector.get(NotificationService);
        notificationService.error(message, vars);
    }
    /**
     * If the server is configured to use the "bearer" tokenMethod, each response should be checked
     * for the existence of an auth token.
     */
    checkForAuthToken(response) {
        if (this.tokenMethod === 'bearer') {
            const authToken = response.headers.get(this.authTokenHeaderKey);
            if (authToken) {
                this.localStorageService.set('authToken', authToken);
            }
        }
    }
    /**
     * Determine if two urls are on the same origin.
     */
    areUrlsOnSameOrigin(urlA, urlB) {
        return new URL(urlA).origin === new URL(urlB).origin;
    }
    /**
     * If the provided `loginUrl` is on the same origin than the AdminUI, return the path
     * after the `/admin`.
     * Else, return the whole login url.
     */
    getPathFromLoginUrl(loginUrl) {
        if (!this.areUrlsOnSameOrigin(loginUrl, window.location.origin)) {
            return loginUrl;
        }
        return loginUrl.split('/admin')[1];
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: DefaultInterceptor, deps: [{ token: i1.DataService }, { token: i0.Injector }, { token: i2.AuthService }, { token: i3.Router }, { token: i4.LocalStorageService }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: DefaultInterceptor }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: DefaultInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i1.DataService }, { type: i0.Injector }, { type: i2.AuthService }, { type: i3.Router }, { type: i4.LocalStorageService }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJjZXB0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL2RhdGEvcHJvdmlkZXJzL2ludGVyY2VwdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCxpQkFBaUIsRUFLakIsWUFBWSxHQUNmLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLFVBQVUsRUFBWSxNQUFNLGVBQWUsQ0FBQztBQUVyRCxPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUMsRUFBRSxNQUFNLHlDQUF5QyxDQUFDO0FBQ3RFLE9BQU8sRUFBRSw2QkFBNkIsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBR3JGLE9BQU8sRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFaEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBR2hELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLG1EQUFtRCxDQUFDOzs7Ozs7QUFJeEYsTUFBTSxDQUFDLE1BQU0sbUJBQW1CLEdBQUcsWUFBWSxDQUFDO0FBRWhEOzs7R0FHRztBQUVILE1BQU0sT0FBTyxrQkFBa0I7SUFJM0IsWUFDWSxXQUF3QixFQUN4QixRQUFrQixFQUNsQixXQUF3QixFQUN4QixNQUFjLEVBQ2QsbUJBQXdDO1FBSnhDLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQ3hCLGFBQVEsR0FBUixRQUFRLENBQVU7UUFDbEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFDeEIsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUNkLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFSbkMsZ0JBQVcsR0FBaUMsUUFBUSxDQUFDO1FBVWxFLElBQUksQ0FBQyxXQUFXLEdBQUcsWUFBWSxFQUFFLENBQUMsV0FBVyxDQUFDO1FBQzlDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxZQUFZLEVBQUUsQ0FBQyxrQkFBa0Is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QTJCO1FBQ2pELElBQUksSUFBSSxDQUFDLFdBQVcsS0FBSyxRQUFRLEVBQUUsQ0FBQztZQUNoQyxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztZQUNoRSxJQUFJLFNBQVMsRUFBRSxDQUFDO2dCQUNaLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQ3pELENBQUM7UUFDTCxDQUFDO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0ssbUJBQW1CLENBQUMsSUFBWSxFQUFFLElBQVk7UUFDbEQsT0FBTyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLEtBQUssSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDO0lBQ3pELENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssbUJBQW1CLENBQUMsUUFBZ0I7UUFDeEMsSUFBSSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1lBQzlELE9BQU8sUUFBUSxDQUFDO1FBQ3BCLENBQUM7UUFDRCxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkMsQ0FBQzs4R0F0SlEsa0JBQWtCO2tIQUFsQixrQkFBa0I7OzJGQUFsQixrQkFBa0I7a0JBRDlCLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEh0dHBFcnJvclJlc3BvbnNlLFxuICAgIEh0dHBFdmVudCxcbiAgICBIdHRwSGFuZGxlcixcbiAgICBIdHRwSW50ZXJjZXB0b3IsXG4gICAgSHR0cFJlcXVlc3QsXG4gICAgSHR0cFJlc3BvbnNlLFxufSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IG1hcmtlciBhcyBfIH0gZnJvbSAnQGJpZXNiamVyZy9uZ3gtdHJhbnNsYXRlLWV4dHJhY3QtbWFya2VyJztcbmltcG9ydCB7IERFRkFVTFRfQVVUSF9UT0tFTl9IRUFERVJfS0VZIH0gZnJvbSAnQHZlbmR1cmUvY29tbW9uL2xpYi9zaGFyZWQtY29uc3RhbnRzJztcbmltcG9ydCB7IEFkbWluVWlDb25maWcgfSBmcm9tICdAdmVuZHVyZS9jb21tb24vbGliL3NoYXJlZC10eXBlcyc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzd2l0Y2hNYXAsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgZ2V0QXBwQ29uZmlnIH0gZnJvbSAnLi4vLi4vYXBwLmNvbmZpZyc7XG5pbXBvcnQgeyBBdXRoU2VydmljZSB9IGZyb20gJy4uLy4uL3Byb3ZpZGVycy9hdXRoL2F1dGguc2VydmljZSc7XG5pbXBvcnQgeyBMb2NhbFN0b3JhZ2VTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vcHJvdmlkZXJzL2xvY2FsLXN0b3JhZ2UvbG9jYWwtc3RvcmFnZS5zZXJ2aWNlJztcbmltcG9ydCB7IE5vdGlmaWNhdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9wcm92aWRlcnMvbm90aWZpY2F0aW9uL25vdGlmaWNhdGlvbi5zZXJ2aWNlJztcblxuaW1wb3J0IHsgRGF0YVNlcnZpY2UgfSBmcm9tICcuL2RhdGEuc2VydmljZSc7XG5cbmV4cG9ydCBjb25zdCBBVVRIX1JFRElSRUNUX1BBUkFNID0gJ3JlZGlyZWN0VG8nO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IGludGVyY2VwdG9yIGV4YW1pbmVzIGFsbCBIVFRQIHJlcXVlc3RzICYgcmVzcG9uc2VzIGFuZCBhdXRvbWF0aWNhbGx5IHVwZGF0ZXMgdGhlIHJlcXVlc3Rpbmcgc3RhdGVcbiAqIGFuZCBzaG93cyBlcnJvciBub3RpZmljYXRpb25zLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGVmYXVsdEludGVyY2VwdG9yIGltcGxlbWVudHMgSHR0cEludGVyY2VwdG9yIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRva2VuTWV0aG9kOiBBZG1pblVpQ29uZmlnWyd0b2tlbk1ldGhvZCddID0gJ2Nvb2tpZSc7XG4gICAgcHJpdmF0ZSByZWFkb25seSBhdXRoVG9rZW5IZWFkZXJLZXk6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGRhdGFTZXJ2aWNlOiBEYXRhU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsXG4gICAgICAgIHByaXZhdGUgYXV0aFNlcnZpY2U6IEF1dGhTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIHJvdXRlcjogUm91dGVyLFxuICAgICAgICBwcml2YXRlIGxvY2FsU3RvcmFnZVNlcnZpY2U6IExvY2FsU3RvcmFnZVNlcnZpY2UsXG4gICAgKSB7XG4gICAgICAgIHRoaXMudG9rZW5NZXRob2QgPSBnZXRBcHBDb25maWcoKS50b2tlbk1ldGhvZDtcbiAgICAgICAgdGhpcy5hdXRoVG9rZW5IZWFkZXJLZXkgPSBnZXRBcHBDb25maWcoKS5hdXRoVG9rZW5IZWFkZXJLZXkgfHwgREVGQVVMVF9BVVRIX1RPS0VOX0hFQURFUl9LRVk7XG4gICAgfVxuXG4gICAgaW50ZXJjZXB0KHJlcTogSHR0cFJlcXVlc3Q8YW55PiwgbmV4dDogSHR0cEhhbmRsZXIpOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PiB7XG4gICAgICAgIHRoaXMuZGF0YVNlcnZpY2UuY2xpZW50LnN0YXJ0UmVxdWVzdCgpLnN1YnNjcmliZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2VydmljZS5jbGllbnQudWlTdGF0ZSgpLnNpbmdsZSQucGlwZShcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoeyB1aVN0YXRlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gcmVxLmNsb25lKHtcbiAgICAgICAgICAgICAgICAgICAgc2V0UGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZUNvZGU6IHVpU3RhdGU/LmNvbnRlbnRMYW5ndWFnZSA/PyAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxdWVzdCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRhcChcbiAgICAgICAgICAgICAgICBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEh0dHBSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0ZvckF1dGhUb2tlbihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeU9uRXJyb3IoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhU2VydmljZS5jbGllbnQuY29tcGxldGVSZXF1ZXN0KCkuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBIdHRwRXJyb3JSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlPbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFTZXJ2aWNlLmNsaWVudC5jb21wbGV0ZVJlcXVlc3QoKS5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUVycm9yTm90aWZpY2F0aW9uKGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgbm90aWZ5T25FcnJvcihyZXNwb25zZTogSHR0cFJlc3BvbnNlPGFueT4gfCBIdHRwRXJyb3JSZXNwb25zZSkge1xuICAgICAgICBpZiAocmVzcG9uc2UgaW5zdGFuY2VvZiBIdHRwRXJyb3JSZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXBpSG9zdCwgYXBpUG9ydCB9ID0gZ2V0QXBwQ29uZmlnKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3JOb3RpZmljYXRpb24oXyhgZXJyb3IuY291bGQtbm90LWNvbm5lY3QtdG8tc2VydmVyYCksIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBgJHthcGlIb3N0fToke2FwaVBvcnR9YCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA1MDMgJiYgcmVzcG9uc2UudXJsPy5lbmRzV2l0aCgnL2hlYWx0aCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3JOb3RpZmljYXRpb24oXyhgZXJyb3IuaGVhbHRoLWNoZWNrLWZhaWxlZGApKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3JOb3RpZmljYXRpb24odGhpcy5leHRyYWN0RXJyb3JGcm9tSHR0cFJlc3BvbnNlKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBHcmFwaFFMIGVycm9ycyBzdGlsbCByZXR1cm4gMjAwIE9LIHJlc3BvbnNlcywgYnV0IGhhdmUgdGhlIGFjdHVhbCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAvLyBpbnNpZGUgdGhlIGJvZHkgb2YgdGhlIHJlc3BvbnNlLlxuICAgICAgICAgICAgY29uc3QgZ3JhcGhRTEVycm9ycyA9IHJlc3BvbnNlLmJvZHkuZXJyb3JzO1xuICAgICAgICAgICAgaWYgKGdyYXBoUUxFcnJvcnMgJiYgQXJyYXkuaXNBcnJheShncmFwaFFMRXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q29kZTogc3RyaW5nID0gZ3JhcGhRTEVycm9yc1swXT8uZXh0ZW5zaW9ucz8uY29kZTtcblxuICAgICAgICAgICAgICAgIGlmIChmaXJzdENvZGUgPT09ICdGT1JCSURERU4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aFNlcnZpY2UubG9nT3V0KCkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbG9naW5VcmwgfSA9IGdldEFwcENvbmZpZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBgbG9naW5VcmxgIHdoaWNoIGlzIGV4dGVybmFsIHRvIHRoZSBBZG1pblVJLCByZWRpcmVjdCB0byBpdCAod2l0aCBubyBxdWVyeSBwYXJhbWV0ZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ2luVXJsICYmICF0aGlzLmFyZVVybHNPblNhbWVPcmlnaW4obG9naW5VcmwsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBsb2dpblVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVsc2UsIHdlIGJ1aWxkIHRoZSBsb2dpbiBwYXRoIGZyb20gdGhlIGxvZ2luIHVybCBpZiBvbmUgaXMgcHJvdmlkZWQgb3IgZmFsbGJhY2sgdG8gYC9sb2dpbmBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2luUGF0aCA9IGxvZ2luVXJsID8gdGhpcy5nZXRQYXRoRnJvbUxvZ2luVXJsKGxvZ2luVXJsKSA6ICcvbG9naW4nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5pbmNsdWRlcyhsb2dpblBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGdyYXBoUUxFcnJvcnNbMF0ucGF0aC5qb2luKCcgPiAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlFcnJvck5vdGlmaWNhdGlvbihfKGBlcnJvci40MDMtZm9yYmlkZGVuYCksIHsgcGF0aCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmF2aWdhdGUgdG8gdGhlIGBsb2dpblBhdGhgIHJvdXRlIGJ5IGVuc3VyaW5nIHRoZSBxdWVyeSBwYXJhbSBpbiBjaGFyZ2Ugb2YgdGhlIHJlZGlyZWN0aW9uIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvdXRlci5uYXZpZ2F0ZShbbG9naW5QYXRoXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtBVVRIX1JFRElSRUNUX1BBUkFNXTogYnRvYSh0aGlzLnJvdXRlci51cmwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaXJzdENvZGUgPT09ICdDSEFOTkVMX05PVF9GT1VORCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGdyYXBoUUxFcnJvcnMubWFwKGVyciA9PiBlcnIubWVzc2FnZSkuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUVycm9yTm90aWZpY2F0aW9uKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2FsU3RvcmFnZVNlcnZpY2UucmVtb3ZlKCdhY3RpdmVDaGFubmVsVG9rZW4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZ3JhcGhRTEVycm9ycy5tYXAoZXJyID0+IGVyci5tZXNzYWdlKS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5RXJyb3JOb3RpZmljYXRpb24obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBleHRyYWN0RXJyb3JGcm9tSHR0cFJlc3BvbnNlKHJlc3BvbnNlOiBIdHRwRXJyb3JSZXNwb25zZSk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IHJlc3BvbnNlLmVycm9yLmVycm9ycztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3JzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9ycy5tYXAoZSA9PiBlLm1lc3NhZ2UpLmpvaW4oJ1xcbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIHRvIGxhemlseSBpbmplY3QgdGhlIE5vdGlmaWNhdGlvblNlcnZpY2Ugc2luY2UgaXQgZGVwZW5kcyBvbiB0aGUgSTE4blNlcnZpY2Ugd2hpY2hcbiAgICAgKiBldmVudHVhbGx5IGRlcGVuZHMgb24gdGhlIEh0dHBDbGllbnQgKHVzZWQgdG8gbG9hZCBtZXNzYWdlcyBmcm9tIGpzb24gZmlsZXMpLiBJZiB3ZSB3ZXJlIHRvXG4gICAgICogZGlyZWN0bHkgaW5qZWN0IE5vdGlmaWNhdGlvblNlcnZpY2UgaW50byB0aGUgY29uc3RydWN0b3IsIHdlIGdldCBhIGN5Y2xpYyBkZXBlbmRlbmN5LlxuICAgICAqL1xuICAgIHByaXZhdGUgZGlzcGxheUVycm9yTm90aWZpY2F0aW9uKG1lc3NhZ2U6IHN0cmluZywgdmFycz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uU2VydmljZSA9IHRoaXMuaW5qZWN0b3IuZ2V0PE5vdGlmaWNhdGlvblNlcnZpY2U+KE5vdGlmaWNhdGlvblNlcnZpY2UpO1xuICAgICAgICBub3RpZmljYXRpb25TZXJ2aWNlLmVycm9yKG1lc3NhZ2UsIHZhcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBzZXJ2ZXIgaXMgY29uZmlndXJlZCB0byB1c2UgdGhlIFwiYmVhcmVyXCIgdG9rZW5NZXRob2QsIGVhY2ggcmVzcG9uc2Ugc2hvdWxkIGJlIGNoZWNrZWRcbiAgICAgKiBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBhdXRoIHRva2VuLlxuICAgICAqL1xuICAgIHByaXZhdGUgY2hlY2tGb3JBdXRoVG9rZW4ocmVzcG9uc2U6IEh0dHBSZXNwb25zZTxhbnk+KSB7XG4gICAgICAgIGlmICh0aGlzLnRva2VuTWV0aG9kID09PSAnYmVhcmVyJykge1xuICAgICAgICAgICAgY29uc3QgYXV0aFRva2VuID0gcmVzcG9uc2UuaGVhZGVycy5nZXQodGhpcy5hdXRoVG9rZW5IZWFkZXJLZXkpO1xuICAgICAgICAgICAgaWYgKGF1dGhUb2tlbikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxTdG9yYWdlU2VydmljZS5zZXQoJ2F1dGhUb2tlbicsIGF1dGhUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgdHdvIHVybHMgYXJlIG9uIHRoZSBzYW1lIG9yaWdpbi5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFyZVVybHNPblNhbWVPcmlnaW4odXJsQTogc3RyaW5nLCB1cmxCOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVUkwodXJsQSkub3JpZ2luID09PSBuZXcgVVJMKHVybEIpLm9yaWdpbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcHJvdmlkZWQgYGxvZ2luVXJsYCBpcyBvbiB0aGUgc2FtZSBvcmlnaW4gdGhhbiB0aGUgQWRtaW5VSSwgcmV0dXJuIHRoZSBwYXRoXG4gICAgICogYWZ0ZXIgdGhlIGAvYWRtaW5gLlxuICAgICAqIEVsc2UsIHJldHVybiB0aGUgd2hvbGUgbG9naW4gdXJsLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0UGF0aEZyb21Mb2dpblVybChsb2dpblVybDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKCF0aGlzLmFyZVVybHNPblNhbWVPcmlnaW4obG9naW5VcmwsIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9naW5Vcmw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2luVXJsLnNwbGl0KCcvYWRtaW4nKVsxXTtcbiAgICB9XG59XG4iXX0=