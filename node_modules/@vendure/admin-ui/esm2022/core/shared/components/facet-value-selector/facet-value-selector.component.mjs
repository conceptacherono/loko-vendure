import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, ViewChild, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NgSelectComponent } from '@ng-select/ng-select';
import { concat, merge, of, Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged, mapTo, switchMap, tap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../../../data/providers/data.service";
import * as i2 from "@angular/common";
import * as i3 from "@angular/forms";
import * as i4 from "@ng-select/ng-select";
import * as i5 from "../chip/chip.component";
import * as i6 from "../facet-value-chip/facet-value-chip.component";
import * as i7 from "@ngx-translate/core";
/**
 * @description
 * A form control for selecting facet values.
 *
 * @example
 * ```HTML
 * <vdr-facet-value-selector
 *   (selectedValuesChange)="selectedValues = $event"
 * ></vdr-facet-value-selector>
 * ```
 * The `selectedValuesChange` event will emit an array of `FacetValue` objects.
 *
 * @docsCategory components
 */
export class FacetValueSelectorComponent {
    constructor(dataService, changeDetectorRef) {
        this.dataService = dataService;
        this.changeDetectorRef = changeDetectorRef;
        this.selectedValuesChange = new EventEmitter();
        this.readonly = false;
        this.transformControlValueAccessorValue = value => value;
        this.searchInput$ = new Subject();
        this.searchLoading = false;
        this.selectedIds$ = new Subject();
        this.disabled = false;
    }
    ngOnInit() {
        this.initSearchResults();
    }
    initSearchResults() {
        const searchItems$ = this.searchInput$.pipe(debounceTime(200), distinctUntilChanged(), tap(() => (this.searchLoading = true)), switchMap(term => {
            if (!term) {
                return of([]);
            }
            return this.dataService.facet
                .getFacetValues({ take: 100, filter: { name: { contains: term } } })
                .mapSingle(result => result.facetValues.items);
        }), tap(() => (this.searchLoading = false)));
        this.subscription = this.selectedIds$
            .pipe(switchMap(ids => {
            if (!ids.length) {
                return of([]);
            }
            return this.dataService.facet
                .getFacetValues({ take: 100, filter: { id: { in: ids } } }, 'cache-first')
                .mapSingle(result => result.facetValues.items);
        }))
            .subscribe(val => {
            this.value = val;
            this.changeDetectorRef.markForCheck();
        });
        const clear$ = this.selectedValuesChange.pipe(mapTo([]));
        this.searchResults$ = concat(of([]), merge(searchItems$, clear$));
    }
    ngOnDestroy() {
        this.subscription?.unsubscribe();
    }
    onChange(selected) {
        if (this.readonly) {
            return;
        }
        for (const sel of selected) {
            console.log(`selected: ${sel.facet.name}:${sel.code}`);
        }
        this.selectedValuesChange.emit(selected);
        if (this.onChangeFn) {
            const transformedValue = this.transformControlValueAccessorValue(selected);
            this.onChangeFn(transformedValue);
        }
    }
    registerOnChange(fn) {
        this.onChangeFn = fn;
    }
    registerOnTouched(fn) {
        this.onTouchFn = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    focus() {
        this.ngSelect.focus();
    }
    writeValue(obj) {
        let valueIds;
        if (typeof obj === 'string') {
            try {
                const facetValueIds = JSON.parse(obj);
                valueIds = facetValueIds;
            }
            catch (err) {
                // TODO: log error
                throw err;
            }
        }
        else if (Array.isArray(obj)) {
            const isIdArray = (input) => input.every(i => typeof i === 'number' || typeof i === 'string');
            if (isIdArray(obj)) {
                valueIds = obj.map(fv => fv.toString());
            }
            else {
                valueIds = obj.map(fv => fv.id);
            }
        }
        if (valueIds) {
            // this.value = valueIds;
            this.selectedIds$.next(valueIds);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: FacetValueSelectorComponent, deps: [{ token: i1.DataService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.4", type: FacetValueSelectorComponent, selector: "vdr-facet-value-selector", inputs: { readonly: "readonly", transformControlValueAccessorValue: "transformControlValueAccessorValue" }, outputs: { selectedValuesChange: "selectedValuesChange" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: FacetValueSelectorComponent,
                multi: true,
            },
        ], viewQueries: [{ propertyName: "ngSelect", first: true, predicate: NgSelectComponent, descendants: true }], ngImport: i0, template: "<ng-select\r\n    [items]=\"searchResults$ | async\"\r\n    [addTag]=\"false\"\r\n    [hideSelected]=\"true\"\r\n    [loading]=\"searchLoading\"\r\n    [typeahead]=\"searchInput$\"\r\n    multiple=\"true\"\r\n    appendTo=\"body\"\r\n    bindLabel=\"id\"\r\n    [disabled]=\"disabled || readonly\"\r\n    [ngModel]=\"value\"\r\n    (change)=\"onChange($event)\"\r\n>\r\n    <ng-template ng-label-tmp let-item=\"item\" let-clear=\"clear\">\r\n        <vdr-facet-value-chip\r\n            *ngIf=\"item; else facetNotFound\"\r\n            [facetValue]=\"item\"\r\n            [removable]=\"!readonly\"\r\n            (remove)=\"clear(item)\"\r\n        ></vdr-facet-value-chip>\r\n        <ng-template #facetNotFound>\r\n            <vdr-chip colorType=\"error\" icon=\"times\" (iconClick)=\"clear(item)\">{{\r\n                'catalog.facet-value-not-available' | translate: { id: item.id }\r\n            }}</vdr-chip>\r\n        </ng-template>\r\n    </ng-template>\r\n    <ng-template ng-option-tmp let-item=\"item\">\r\n        <vdr-facet-value-chip [facetValue]=\"item\" [removable]=\"false\"></vdr-facet-value-chip>\r\n    </ng-template>\r\n</ng-select>\r\n", styles: [""], dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i3.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i4.NgSelectComponent, selector: "ng-select", inputs: ["bindLabel", "bindValue", "markFirst", "placeholder", "notFoundText", "typeToSearchText", "addTagText", "loadingText", "clearAllText", "appearance", "dropdownPosition", "appendTo", "loading", "closeOnSelect", "hideSelected", "selectOnTab", "openOnEnter", "maxSelectedItems", "groupBy", "groupValue", "bufferAmount", "virtualScroll", "selectableGroup", "selectableGroupAsModel", "searchFn", "trackByFn", "clearOnBackspace", "labelForId", "inputAttrs", "tabIndex", "readonly", "searchWhileComposing", "minTermLength", "editableSearchTerm", "keyDownFn", "typeahead", "multiple", "addTag", "searchable", "clearable", "isOpen", "items", "compareWith", "clearSearchOnAdd", "deselectOnClick"], outputs: ["blur", "focus", "change", "open", "close", "search", "clear", "add", "remove", "scroll", "scrollToEnd"] }, { kind: "directive", type: i4.NgOptionTemplateDirective, selector: "[ng-option-tmp]" }, { kind: "directive", type: i4.NgLabelTemplateDirective, selector: "[ng-label-tmp]" }, { kind: "component", type: i5.ChipComponent, selector: "vdr-chip", inputs: ["icon", "invert", "colorFrom", "colorType"], outputs: ["iconClick"] }, { kind: "component", type: i6.FacetValueChipComponent, selector: "vdr-facet-value-chip", inputs: ["facetValue", "removable", "displayFacetName"], outputs: ["remove"] }, { kind: "pipe", type: i2.AsyncPipe, name: "async" }, { kind: "pipe", type: i7.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: FacetValueSelectorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-facet-value-selector', changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: FacetValueSelectorComponent,
                            multi: true,
                        },
                    ], template: "<ng-select\r\n    [items]=\"searchResults$ | async\"\r\n    [addTag]=\"false\"\r\n    [hideSelected]=\"true\"\r\n    [loading]=\"searchLoading\"\r\n    [typeahead]=\"searchInput$\"\r\n    multiple=\"true\"\r\n    appendTo=\"body\"\r\n    bindLabel=\"id\"\r\n    [disabled]=\"disabled || readonly\"\r\n    [ngModel]=\"value\"\r\n    (change)=\"onChange($event)\"\r\n>\r\n    <ng-template ng-label-tmp let-item=\"item\" let-clear=\"clear\">\r\n        <vdr-facet-value-chip\r\n            *ngIf=\"item; else facetNotFound\"\r\n            [facetValue]=\"item\"\r\n            [removable]=\"!readonly\"\r\n            (remove)=\"clear(item)\"\r\n        ></vdr-facet-value-chip>\r\n        <ng-template #facetNotFound>\r\n            <vdr-chip colorType=\"error\" icon=\"times\" (iconClick)=\"clear(item)\">{{\r\n                'catalog.facet-value-not-available' | translate: { id: item.id }\r\n            }}</vdr-chip>\r\n        </ng-template>\r\n    </ng-template>\r\n    <ng-template ng-option-tmp let-item=\"item\">\r\n        <vdr-facet-value-chip [facetValue]=\"item\" [removable]=\"false\"></vdr-facet-value-chip>\r\n    </ng-template>\r\n</ng-select>\r\n" }]
        }], ctorParameters: () => [{ type: i1.DataService }, { type: i0.ChangeDetectorRef }], propDecorators: { selectedValuesChange: [{
                type: Output
            }], readonly: [{
                type: Input
            }], transformControlValueAccessorValue: [{
                type: Input
            }], ngSelect: [{
                type: ViewChild,
                args: [NgSelectComponent]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFjZXQtdmFsdWUtc2VsZWN0b3IuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jb3JlL3NyYy9zaGFyZWQvY29tcG9uZW50cy9mYWNldC12YWx1ZS1zZWxlY3Rvci9mYWNldC12YWx1ZS1zZWxlY3Rvci5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3NoYXJlZC9jb21wb25lbnRzL2ZhY2V0LXZhbHVlLXNlbGVjdG9yL2ZhY2V0LXZhbHVlLXNlbGVjdG9yLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCx1QkFBdUIsRUFFdkIsU0FBUyxFQUNULFlBQVksRUFDWixLQUFLLEVBR0wsTUFBTSxFQUNOLFNBQVMsR0FDWixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDekUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDekQsT0FBTyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQWMsRUFBRSxFQUFFLE9BQU8sRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDNUUsT0FBTyxFQUFFLFlBQVksRUFBRSxvQkFBb0IsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7Ozs7Ozs7QUFLM0Y7Ozs7Ozs7Ozs7Ozs7R0FhRztBQWNILE1BQU0sT0FBTywyQkFBMkI7SUFnQnBDLFlBQ1ksV0FBd0IsRUFDeEIsaUJBQW9DO1FBRHBDLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQ3hCLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUFqQnRDLHlCQUFvQixHQUFHLElBQUksWUFBWSxFQUF3QixDQUFDO1FBQ2pFLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIsdUNBQWtDLEdBQTJDLEtB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cmF0ZWd5LFxyXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICBDb21wb25lbnQsXHJcbiAgICBFdmVudEVtaXR0ZXIsXHJcbiAgICBJbnB1dCxcclxuICAgIE9uRGVzdHJveSxcclxuICAgIE9uSW5pdCxcclxuICAgIE91dHB1dCxcclxuICAgIFZpZXdDaGlsZCxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBOZ1NlbGVjdENvbXBvbmVudCB9IGZyb20gJ0BuZy1zZWxlY3Qvbmctc2VsZWN0JztcclxuaW1wb3J0IHsgY29uY2F0LCBtZXJnZSwgT2JzZXJ2YWJsZSwgb2YsIFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXBUbywgc3dpdGNoTWFwLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBGYWNldFZhbHVlLCBGYWNldFZhbHVlRnJhZ21lbnQgfSBmcm9tICcuLi8uLi8uLi9jb21tb24vZ2VuZXJhdGVkLXR5cGVzJztcclxuaW1wb3J0IHsgRGF0YVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9kYXRhL3Byb3ZpZGVycy9kYXRhLnNlcnZpY2UnO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBIGZvcm0gY29udHJvbCBmb3Igc2VsZWN0aW5nIGZhY2V0IHZhbHVlcy5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogYGBgSFRNTFxyXG4gKiA8dmRyLWZhY2V0LXZhbHVlLXNlbGVjdG9yXHJcbiAqICAgKHNlbGVjdGVkVmFsdWVzQ2hhbmdlKT1cInNlbGVjdGVkVmFsdWVzID0gJGV2ZW50XCJcclxuICogPjwvdmRyLWZhY2V0LXZhbHVlLXNlbGVjdG9yPlxyXG4gKiBgYGBcclxuICogVGhlIGBzZWxlY3RlZFZhbHVlc0NoYW5nZWAgZXZlbnQgd2lsbCBlbWl0IGFuIGFycmF5IG9mIGBGYWNldFZhbHVlYCBvYmplY3RzLlxyXG4gKlxyXG4gKiBAZG9jc0NhdGVnb3J5IGNvbXBvbmVudHNcclxuICovXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd2ZHItZmFjZXQtdmFsdWUtc2VsZWN0b3InLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL2ZhY2V0LXZhbHVlLXNlbGVjdG9yLmNvbXBvbmVudC5odG1sJyxcclxuICAgIHN0eWxlVXJsczogWycuL2ZhY2V0LXZhbHVlLXNlbGVjdG9yLmNvbXBvbmVudC5zY3NzJ10sXHJcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXHJcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBGYWNldFZhbHVlU2VsZWN0b3JDb21wb25lbnQsXHJcbiAgICAgICAgICAgIG11bHRpOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICBdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRmFjZXRWYWx1ZVNlbGVjdG9yQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3ksIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcclxuICAgIEBPdXRwdXQoKSBzZWxlY3RlZFZhbHVlc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8RmFjZXRWYWx1ZUZyYWdtZW50W10+KCk7XHJcbiAgICBASW5wdXQoKSByZWFkb25seSA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgdHJhbnNmb3JtQ29udHJvbFZhbHVlQWNjZXNzb3JWYWx1ZTogKHZhbHVlOiBGYWNldFZhbHVlRnJhZ21lbnRbXSkgPT4gYW55W10gPSB2YWx1ZSA9PiB2YWx1ZTtcclxuICAgIHNlYXJjaElucHV0JCA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcclxuICAgIHNlYXJjaExvYWRpbmcgPSBmYWxzZTtcclxuICAgIHNlYXJjaFJlc3VsdHMkOiBPYnNlcnZhYmxlPEZhY2V0VmFsdWVGcmFnbWVudFtdPjtcclxuICAgIHNlbGVjdGVkSWRzJCA9IG5ldyBTdWJqZWN0PHN0cmluZ1tdPigpO1xyXG5cclxuICAgIEBWaWV3Q2hpbGQoTmdTZWxlY3RDb21wb25lbnQpIHByaXZhdGUgbmdTZWxlY3Q6IE5nU2VsZWN0Q29tcG9uZW50O1xyXG5cclxuICAgIG9uQ2hhbmdlRm46ICh2YWw6IGFueSkgPT4gdm9pZDtcclxuICAgIG9uVG91Y2hGbjogKCkgPT4gdm9pZDtcclxuICAgIGRpc2FibGVkID0gZmFsc2U7XHJcbiAgICB2YWx1ZTogQXJyYXk8c3RyaW5nIHwgRmFjZXRWYWx1ZUZyYWdtZW50PjtcclxuICAgIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIGRhdGFTZXJ2aWNlOiBEYXRhU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcclxuICAgICkge31cclxuXHJcbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmluaXRTZWFyY2hSZXN1bHRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbml0U2VhcmNoUmVzdWx0cygpIHtcclxuICAgICAgICBjb25zdCBzZWFyY2hJdGVtcyQgPSB0aGlzLnNlYXJjaElucHV0JC5waXBlKFxyXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWUoMjAwKSxcclxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcclxuICAgICAgICAgICAgdGFwKCgpID0+ICh0aGlzLnNlYXJjaExvYWRpbmcgPSB0cnVlKSksXHJcbiAgICAgICAgICAgIHN3aXRjaE1hcCh0ZXJtID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGVybSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZihbXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2VydmljZS5mYWNldFxyXG4gICAgICAgICAgICAgICAgICAgIC5nZXRGYWNldFZhbHVlcyh7IHRha2U6IDEwMCwgZmlsdGVyOiB7IG5hbWU6IHsgY29udGFpbnM6IHRlcm0gfSB9IH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcFNpbmdsZShyZXN1bHQgPT4gcmVzdWx0LmZhY2V0VmFsdWVzLml0ZW1zKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHRhcCgoKSA9PiAodGhpcy5zZWFyY2hMb2FkaW5nID0gZmFsc2UpKSxcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5zZWxlY3RlZElkcyRcclxuICAgICAgICAgICAgLnBpcGUoXHJcbiAgICAgICAgICAgICAgICBzd2l0Y2hNYXAoaWRzID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mKFtdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNlcnZpY2UuZmFjZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEZhY2V0VmFsdWVzKHsgdGFrZTogMTAwLCBmaWx0ZXI6IHsgaWQ6IHsgaW46IGlkcyB9IH0gfSwgJ2NhY2hlLWZpcnN0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcFNpbmdsZShyZXN1bHQgPT4gcmVzdWx0LmZhY2V0VmFsdWVzLml0ZW1zKTtcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodmFsID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgY2xlYXIkID0gdGhpcy5zZWxlY3RlZFZhbHVlc0NoYW5nZS5waXBlKG1hcFRvKFtdKSk7XHJcbiAgICAgICAgdGhpcy5zZWFyY2hSZXN1bHRzJCA9IGNvbmNhdChvZihbXSksIG1lcmdlKHNlYXJjaEl0ZW1zJCwgY2xlYXIkKSk7XHJcbiAgICB9XHJcbiAgICBuZ09uRGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkNoYW5nZShzZWxlY3RlZDogRmFjZXRWYWx1ZUZyYWdtZW50W10pIHtcclxuICAgICAgICBpZiAodGhpcy5yZWFkb25seSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qgc2VsIG9mIHNlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBzZWxlY3RlZDogJHtzZWwuZmFjZXQubmFtZX06JHtzZWwuY29kZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlc0NoYW5nZS5lbWl0KHNlbGVjdGVkKTtcclxuICAgICAgICBpZiAodGhpcy5vbkNoYW5nZUZuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWUgPSB0aGlzLnRyYW5zZm9ybUNvbnRyb2xWYWx1ZUFjY2Vzc29yVmFsdWUoc2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlRm4odHJhbnNmb3JtZWRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2VGbiA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpIHtcclxuICAgICAgICB0aGlzLm9uVG91Y2hGbiA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZvY3VzKCkge1xyXG4gICAgICAgIHRoaXMubmdTZWxlY3QuZm9jdXMoKTtcclxuICAgIH1cclxuXHJcbiAgICB3cml0ZVZhbHVlKG9iajogc3RyaW5nIHwgRmFjZXRWYWx1ZUZyYWdtZW50W10gfCBBcnJheTxzdHJpbmcgfCBudW1iZXI+IHwgbnVsbCk6IHZvaWQge1xyXG4gICAgICAgIGxldCB2YWx1ZUlkczogc3RyaW5nW10gfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmYWNldFZhbHVlSWRzID0gSlNPTi5wYXJzZShvYmopIGFzIHN0cmluZ1tdO1xyXG4gICAgICAgICAgICAgICAgdmFsdWVJZHMgPSBmYWNldFZhbHVlSWRzO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGxvZyBlcnJvclxyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgY29uc3QgaXNJZEFycmF5ID0gKGlucHV0OiB1bmtub3duW10pOiBpbnB1dCBpcyBBcnJheTxzdHJpbmcgfCBudW1iZXI+ID0+XHJcbiAgICAgICAgICAgICAgICBpbnB1dC5ldmVyeShpID0+IHR5cGVvZiBpID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgaSA9PT0gJ3N0cmluZycpO1xyXG4gICAgICAgICAgICBpZiAoaXNJZEFycmF5KG9iaikpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlSWRzID0gb2JqLm1hcChmdiA9PiBmdi50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlSWRzID0gb2JqLm1hcChmdiA9PiBmdi5pZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlSWRzKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMudmFsdWUgPSB2YWx1ZUlkcztcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZElkcyQubmV4dCh2YWx1ZUlkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIjxuZy1zZWxlY3RcclxuICAgIFtpdGVtc109XCJzZWFyY2hSZXN1bHRzJCB8IGFzeW5jXCJcclxuICAgIFthZGRUYWddPVwiZmFsc2VcIlxyXG4gICAgW2hpZGVTZWxlY3RlZF09XCJ0cnVlXCJcclxuICAgIFtsb2FkaW5nXT1cInNlYXJjaExvYWRpbmdcIlxyXG4gICAgW3R5cGVhaGVhZF09XCJzZWFyY2hJbnB1dCRcIlxyXG4gICAgbXVsdGlwbGU9XCJ0cnVlXCJcclxuICAgIGFwcGVuZFRvPVwiYm9keVwiXHJcbiAgICBiaW5kTGFiZWw9XCJpZFwiXHJcbiAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWQgfHwgcmVhZG9ubHlcIlxyXG4gICAgW25nTW9kZWxdPVwidmFsdWVcIlxyXG4gICAgKGNoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCJcclxuPlxyXG4gICAgPG5nLXRlbXBsYXRlIG5nLWxhYmVsLXRtcCBsZXQtaXRlbT1cIml0ZW1cIiBsZXQtY2xlYXI9XCJjbGVhclwiPlxyXG4gICAgICAgIDx2ZHItZmFjZXQtdmFsdWUtY2hpcFxyXG4gICAgICAgICAgICAqbmdJZj1cIml0ZW07IGVsc2UgZmFjZXROb3RGb3VuZFwiXHJcbiAgICAgICAgICAgIFtmYWNldFZhbHVlXT1cIml0ZW1cIlxyXG4gICAgICAgICAgICBbcmVtb3ZhYmxlXT1cIiFyZWFkb25seVwiXHJcbiAgICAgICAgICAgIChyZW1vdmUpPVwiY2xlYXIoaXRlbSlcIlxyXG4gICAgICAgID48L3Zkci1mYWNldC12YWx1ZS1jaGlwPlxyXG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjZmFjZXROb3RGb3VuZD5cclxuICAgICAgICAgICAgPHZkci1jaGlwIGNvbG9yVHlwZT1cImVycm9yXCIgaWNvbj1cInRpbWVzXCIgKGljb25DbGljayk9XCJjbGVhcihpdGVtKVwiPnt7XHJcbiAgICAgICAgICAgICAgICAnY2F0YWxvZy5mYWNldC12YWx1ZS1ub3QtYXZhaWxhYmxlJyB8IHRyYW5zbGF0ZTogeyBpZDogaXRlbS5pZCB9XHJcbiAgICAgICAgICAgIH19PC92ZHItY2hpcD5cclxuICAgICAgICA8L25nLXRlbXBsYXRlPlxyXG4gICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgIDxuZy10ZW1wbGF0ZSBuZy1vcHRpb24tdG1wIGxldC1pdGVtPVwiaXRlbVwiPlxyXG4gICAgICAgIDx2ZHItZmFjZXQtdmFsdWUtY2hpcCBbZmFjZXRWYWx1ZV09XCJpdGVtXCIgW3JlbW92YWJsZV09XCJmYWxzZVwiPjwvdmRyLWZhY2V0LXZhbHVlLWNoaXA+XHJcbiAgICA8L25nLXRlbXBsYXRlPlxyXG48L25nLXNlbGVjdD5cclxuIl19