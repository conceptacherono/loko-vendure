import { ChangeDetectionStrategy, Component, EventEmitter, Output, ViewChild } from '@angular/core';
import { concat, merge, of, Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged, mapTo, switchMap, tap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../../../data/providers/data.service";
import * as i2 from "@ng-select/ng-select";
import * as i3 from "@angular/common";
import * as i4 from "@ngx-translate/core";
import * as i5 from "../../pipes/asset-preview.pipe";
/**
 * @description
 * A component for selecting product variants via an autocomplete-style select input.
 *
 * @example
 * ```HTML
 * <vdr-product-variant-selector
 *   (productSelected)="selectResult($event)"></vdr-product-variant-selector>
 * ```
 *
 * @docsCategory components
 */
export class ProductVariantSelectorComponent {
    constructor(dataService) {
        this.dataService = dataService;
        this.searchInput$ = new Subject();
        this.searchLoading = false;
        this.productSelected = new EventEmitter();
    }
    ngOnInit() {
        this.initSearchResults();
    }
    initSearchResults() {
        const searchItems$ = this.searchInput$.pipe(debounceTime(200), distinctUntilChanged(), tap(() => (this.searchLoading = true)), switchMap(term => {
            if (!term) {
                return of([]);
            }
            return this.dataService.product
                .productSelectorSearch(term, 10)
                .mapSingle(result => result.search.items);
        }), tap(() => (this.searchLoading = false)));
        const clear$ = this.productSelected.pipe(mapTo([]));
        this.searchResults$ = concat(of([]), merge(searchItems$, clear$));
    }
    selectResult(product) {
        if (product) {
            this.productSelected.emit(product);
            this.ngSelect.clearModel();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: ProductVariantSelectorComponent, deps: [{ token: i1.DataService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.4", type: ProductVariantSelectorComponent, selector: "vdr-product-variant-selector", outputs: { productSelected: "productSelected" }, viewQueries: [{ propertyName: "ngSelect", first: true, predicate: ["autoComplete"], descendants: true, static: true }], ngImport: i0, template: "<ng-select\r\n    #autoComplete\r\n    [items]=\"searchResults$ | async\"\r\n    [addTag]=\"false\"\r\n    [multiple]=\"false\"\r\n    [hideSelected]=\"true\"\r\n    [loading]=\"searchLoading\"\r\n    [typeahead]=\"searchInput$\"\r\n    [appendTo]=\"'body'\"\r\n    [placeholder]=\"'settings.search-by-product-name-or-sku' | translate\"\r\n    (change)=\"selectResult($event)\"\r\n>\r\n    <ng-template ng-option-tmp let-item=\"item\">\r\n        <img [src]=\"item.productAsset | assetPreview: 32\">\r\n        {{ item.productVariantName }}\r\n        <small class=\"sku\">{{ item.sku }}</small>\r\n    </ng-template>\r\n</ng-select>\r\n", styles: [":host{display:block}.sku{margin-inline-start:12px;color:var(--color-grey-500)}img{border-radius:var(--border-radius-img)}\n"], dependencies: [{ kind: "component", type: i2.NgSelectComponent, selector: "ng-select", inputs: ["bindLabel", "bindValue", "markFirst", "placeholder", "notFoundText", "typeToSearchText", "addTagText", "loadingText", "clearAllText", "appearance", "dropdownPosition", "appendTo", "loading", "closeOnSelect", "hideSelected", "selectOnTab", "openOnEnter", "maxSelectedItems", "groupBy", "groupValue", "bufferAmount", "virtualScroll", "selectableGroup", "selectableGroupAsModel", "searchFn", "trackByFn", "clearOnBackspace", "labelForId", "inputAttrs", "tabIndex", "readonly", "searchWhileComposing", "minTermLength", "editableSearchTerm", "keyDownFn", "typeahead", "multiple", "addTag", "searchable", "clearable", "isOpen", "items", "compareWith", "clearSearchOnAdd", "deselectOnClick"], outputs: ["blur", "focus", "change", "open", "close", "search", "clear", "add", "remove", "scroll", "scrollToEnd"] }, { kind: "directive", type: i2.NgOptionTemplateDirective, selector: "[ng-option-tmp]" }, { kind: "pipe", type: i3.AsyncPipe, name: "async" }, { kind: "pipe", type: i4.TranslatePipe, name: "translate" }, { kind: "pipe", type: i5.AssetPreviewPipe, name: "assetPreview" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: ProductVariantSelectorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-product-variant-selector', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-select\r\n    #autoComplete\r\n    [items]=\"searchResults$ | async\"\r\n    [addTag]=\"false\"\r\n    [multiple]=\"false\"\r\n    [hideSelected]=\"true\"\r\n    [loading]=\"searchLoading\"\r\n    [typeahead]=\"searchInput$\"\r\n    [appendTo]=\"'body'\"\r\n    [placeholder]=\"'settings.search-by-product-name-or-sku' | translate\"\r\n    (change)=\"selectResult($event)\"\r\n>\r\n    <ng-template ng-option-tmp let-item=\"item\">\r\n        <img [src]=\"item.productAsset | assetPreview: 32\">\r\n        {{ item.productVariantName }}\r\n        <small class=\"sku\">{{ item.sku }}</small>\r\n    </ng-template>\r\n</ng-select>\r\n", styles: [":host{display:block}.sku{margin-inline-start:12px;color:var(--color-grey-500)}img{border-radius:var(--border-radius-img)}\n"] }]
        }], ctorParameters: () => [{ type: i1.DataService }], propDecorators: { productSelected: [{
                type: Output
            }], ngSelect: [{
                type: ViewChild,
                args: ['autoComplete', { static: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZHVjdC12YXJpYW50LXNlbGVjdG9yLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY29yZS9zcmMvc2hhcmVkL2NvbXBvbmVudHMvcHJvZHVjdC12YXJpYW50LXNlbGVjdG9yL3Byb2R1Y3QtdmFyaWFudC1zZWxlY3Rvci5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3NoYXJlZC9jb21wb25lbnRzL3Byb2R1Y3QtdmFyaWFudC1zZWxlY3Rvci9wcm9kdWN0LXZhcmlhbnQtc2VsZWN0b3IuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQVUsTUFBTSxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUU1RyxPQUFPLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBYyxFQUFFLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzlELE9BQU8sRUFBRSxZQUFZLEVBQUUsb0JBQW9CLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7OztBQUszRjs7Ozs7Ozs7Ozs7R0FXRztBQU9ILE1BQU0sT0FBTywrQkFBK0I7SUFReEMsWUFBb0IsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFQNUMsaUJBQVksR0FBRyxJQUFJLE9BQU8sRUFBVSxDQUFDO1FBQ3JDLGtCQUFhLEdBQUcsS0FBSyxDQUFDO1FBRVosb0JBQWUsR0FBRyxJQUFJLFlBQVksRUFBeUQsQ0FBQztJQUl2RCxDQUFDO0lBRWhELFFBQVE7UUFDSixJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRU8saUJBQWlCO1FBQ3JCLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUN2QyxZQUFZLENBQUMsR0FBRyxDQUFDLEVBQ2pCLG9CQUFvQixFQUFFLEVBQ3RCLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFDdEMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2IsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNSLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2xCLENBQUM7WUFDRCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTztpQkFDMUIscUJBQXFCLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQztpQkFDL0IsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNsRCxDQUFDLENBQUMsRUFDRixHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQzFDLENBQUM7UUFFRixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwRCxJQUFJLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLFlBQVksRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7SUFFRCxZQUFZLENBQUMsT0FBK0Q7UUFDeEUsSUFBSSxPQUFPLEVBQUUsQ0FBQztZQUNWLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ25DLElBQUksQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDL0IsQ0FBQztJQUNMLENBQUM7OEdBdkNRLCtCQUErQjtrR0FBL0IsK0JBQStCLDZPQzFCNUMsK25CQWtCQTs7MkZEUWEsK0JBQStCO2tCQU4zQyxTQUFTOytCQUNJLDhCQUE4QixtQkFHdkIsdUJBQXVCLENBQUMsTUFBTTtnRkFNckMsZUFBZTtzQkFBeEIsTUFBTTtnQkFHQyxRQUFRO3NCQURmLFNBQVM7dUJBQUMsY0FBYyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgT25Jbml0LCBPdXRwdXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBOZ1NlbGVjdENvbXBvbmVudCB9IGZyb20gJ0BuZy1zZWxlY3Qvbmctc2VsZWN0JztcclxuaW1wb3J0IHsgY29uY2F0LCBtZXJnZSwgT2JzZXJ2YWJsZSwgb2YsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZGVib3VuY2VUaW1lLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwVG8sIHN3aXRjaE1hcCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgUHJvZHVjdFNlbGVjdG9yU2VhcmNoUXVlcnkgfSBmcm9tICcuLi8uLi8uLi9jb21tb24vZ2VuZXJhdGVkLXR5cGVzJztcclxuaW1wb3J0IHsgRGF0YVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9kYXRhL3Byb3ZpZGVycy9kYXRhLnNlcnZpY2UnO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBBIGNvbXBvbmVudCBmb3Igc2VsZWN0aW5nIHByb2R1Y3QgdmFyaWFudHMgdmlhIGFuIGF1dG9jb21wbGV0ZS1zdHlsZSBzZWxlY3QgaW5wdXQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYEhUTUxcclxuICogPHZkci1wcm9kdWN0LXZhcmlhbnQtc2VsZWN0b3JcclxuICogICAocHJvZHVjdFNlbGVjdGVkKT1cInNlbGVjdFJlc3VsdCgkZXZlbnQpXCI+PC92ZHItcHJvZHVjdC12YXJpYW50LXNlbGVjdG9yPlxyXG4gKiBgYGBcclxuICpcclxuICogQGRvY3NDYXRlZ29yeSBjb21wb25lbnRzXHJcbiAqL1xyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndmRyLXByb2R1Y3QtdmFyaWFudC1zZWxlY3RvcicsXHJcbiAgICB0ZW1wbGF0ZVVybDogJy4vcHJvZHVjdC12YXJpYW50LXNlbGVjdG9yLmNvbXBvbmVudC5odG1sJyxcclxuICAgIHN0eWxlVXJsczogWycuL3Byb2R1Y3QtdmFyaWFudC1zZWxlY3Rvci5jb21wb25lbnQuc2NzcyddLFxyXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBQcm9kdWN0VmFyaWFudFNlbGVjdG9yQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcclxuICAgIHNlYXJjaElucHV0JCA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcclxuICAgIHNlYXJjaExvYWRpbmcgPSBmYWxzZTtcclxuICAgIHNlYXJjaFJlc3VsdHMkOiBPYnNlcnZhYmxlPFByb2R1Y3RTZWxlY3RvclNlYXJjaFF1ZXJ5WydzZWFyY2gnXVsnaXRlbXMnXT47XHJcbiAgICBAT3V0cHV0KCkgcHJvZHVjdFNlbGVjdGVkID0gbmV3IEV2ZW50RW1pdHRlcjxQcm9kdWN0U2VsZWN0b3JTZWFyY2hRdWVyeVsnc2VhcmNoJ11bJ2l0ZW1zJ11bbnVtYmVyXT4oKTtcclxuXHJcbiAgICBAVmlld0NoaWxkKCdhdXRvQ29tcGxldGUnLCB7IHN0YXRpYzogdHJ1ZSB9KVxyXG4gICAgcHJpdmF0ZSBuZ1NlbGVjdDogTmdTZWxlY3RDb21wb25lbnQ7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRhdGFTZXJ2aWNlOiBEYXRhU2VydmljZSkge31cclxuXHJcbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmluaXRTZWFyY2hSZXN1bHRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbml0U2VhcmNoUmVzdWx0cygpIHtcclxuICAgICAgICBjb25zdCBzZWFyY2hJdGVtcyQgPSB0aGlzLnNlYXJjaElucHV0JC5waXBlKFxyXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWUoMjAwKSxcclxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcclxuICAgICAgICAgICAgdGFwKCgpID0+ICh0aGlzLnNlYXJjaExvYWRpbmcgPSB0cnVlKSksXHJcbiAgICAgICAgICAgIHN3aXRjaE1hcCh0ZXJtID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGVybSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvZihbXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU2VydmljZS5wcm9kdWN0XHJcbiAgICAgICAgICAgICAgICAgICAgLnByb2R1Y3RTZWxlY3RvclNlYXJjaCh0ZXJtLCAxMClcclxuICAgICAgICAgICAgICAgICAgICAubWFwU2luZ2xlKHJlc3VsdCA9PiByZXN1bHQuc2VhcmNoLml0ZW1zKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIHRhcCgoKSA9PiAodGhpcy5zZWFyY2hMb2FkaW5nID0gZmFsc2UpKSxcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBjb25zdCBjbGVhciQgPSB0aGlzLnByb2R1Y3RTZWxlY3RlZC5waXBlKG1hcFRvKFtdKSk7XHJcbiAgICAgICAgdGhpcy5zZWFyY2hSZXN1bHRzJCA9IGNvbmNhdChvZihbXSksIG1lcmdlKHNlYXJjaEl0ZW1zJCwgY2xlYXIkKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc2VsZWN0UmVzdWx0KHByb2R1Y3Q/OiBQcm9kdWN0U2VsZWN0b3JTZWFyY2hRdWVyeVsnc2VhcmNoJ11bJ2l0ZW1zJ11bbnVtYmVyXSkge1xyXG4gICAgICAgIGlmIChwcm9kdWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZHVjdFNlbGVjdGVkLmVtaXQocHJvZHVjdCk7XHJcbiAgICAgICAgICAgIHRoaXMubmdTZWxlY3QuY2xlYXJNb2RlbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCI8bmctc2VsZWN0XHJcbiAgICAjYXV0b0NvbXBsZXRlXHJcbiAgICBbaXRlbXNdPVwic2VhcmNoUmVzdWx0cyQgfCBhc3luY1wiXHJcbiAgICBbYWRkVGFnXT1cImZhbHNlXCJcclxuICAgIFttdWx0aXBsZV09XCJmYWxzZVwiXHJcbiAgICBbaGlkZVNlbGVjdGVkXT1cInRydWVcIlxyXG4gICAgW2xvYWRpbmddPVwic2VhcmNoTG9hZGluZ1wiXHJcbiAgICBbdHlwZWFoZWFkXT1cInNlYXJjaElucHV0JFwiXHJcbiAgICBbYXBwZW5kVG9dPVwiJ2JvZHknXCJcclxuICAgIFtwbGFjZWhvbGRlcl09XCInc2V0dGluZ3Muc2VhcmNoLWJ5LXByb2R1Y3QtbmFtZS1vci1za3UnIHwgdHJhbnNsYXRlXCJcclxuICAgIChjaGFuZ2UpPVwic2VsZWN0UmVzdWx0KCRldmVudClcIlxyXG4+XHJcbiAgICA8bmctdGVtcGxhdGUgbmctb3B0aW9uLXRtcCBsZXQtaXRlbT1cIml0ZW1cIj5cclxuICAgICAgICA8aW1nIFtzcmNdPVwiaXRlbS5wcm9kdWN0QXNzZXQgfCBhc3NldFByZXZpZXc6IDMyXCI+XHJcbiAgICAgICAge3sgaXRlbS5wcm9kdWN0VmFyaWFudE5hbWUgfX1cclxuICAgICAgICA8c21hbGwgY2xhc3M9XCJza3VcIj57eyBpdGVtLnNrdSB9fTwvc21hbGw+XHJcbiAgICA8L25nLXRlbXBsYXRlPlxyXG48L25nLXNlbGVjdD5cclxuIl19