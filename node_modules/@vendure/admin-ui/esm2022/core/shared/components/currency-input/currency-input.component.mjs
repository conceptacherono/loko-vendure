import { Component, EventEmitter, Input, Output, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { BehaviorSubject, combineLatest } from 'rxjs';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "../../../data/providers/data.service";
import * as i2 from "../../../providers/currency/currency.service";
import * as i3 from "../affixed-input/affixed-input.component";
import * as i4 from "../form-field/form-field-control.directive";
import * as i5 from "@angular/common";
import * as i6 from "../../pipes/locale-currency-name.pipe";
/**
 * @description
 * A form input control which displays currency in decimal format, whilst working
 * with the integer cent value in the background.
 *
 * @example
 * ```HTML
 * <vdr-currency-input
 *     [(ngModel)]="entityPrice"
 *     [currencyCode]="currencyCode"
 * ></vdr-currency-input>
 * ```
 *
 * @docsCategory components
 */
export class CurrencyInputComponent {
    constructor(dataService, currencyService) {
        this.dataService = dataService;
        this.currencyService = currencyService;
        this.disabled = false;
        this.readonly = false;
        this.currencyCode = '';
        this.valueChange = new EventEmitter();
        this.hasFractionPart = true;
        this.currencyCode$ = new BehaviorSubject('');
        this.precision = currencyService.precision;
        this.precisionFactor = currencyService.precisionFactor;
    }
    ngOnInit() {
        const languageCode$ = this.dataService.client.uiState().mapStream(data => data.uiState.language);
        const shouldPrefix$ = combineLatest(languageCode$, this.currencyCode$).pipe(map(([languageCode, currencyCode]) => {
            if (!currencyCode) {
                return '';
            }
            const locale = languageCode.replace(/_/g, '-');
            const parts = new Intl.NumberFormat(locale, {
                style: 'currency',
                currency: currencyCode,
                currencyDisplay: 'symbol',
            }).formatToParts();
            const NaNString = parts.find(p => p.type === 'nan')?.value ?? 'NaN';
            const localised = new Intl.NumberFormat(locale, {
                style: 'currency',
                currency: currencyCode,
                currencyDisplay: 'symbol',
            }).format(undefined);
            return localised.indexOf(NaNString) > 0;
        }));
        this.prefix$ = shouldPrefix$.pipe(map(shouldPrefix => (shouldPrefix ? this.currencyCode : '')));
        this.suffix$ = shouldPrefix$.pipe(map(shouldPrefix => (shouldPrefix ? '' : this.currencyCode)));
        this.subscription = combineLatest(languageCode$, this.currencyCode$).subscribe(([languageCode, currencyCode]) => {
            if (!currencyCode) {
                return '';
            }
            const locale = languageCode.replace(/_/g, '-');
            const parts = new Intl.NumberFormat(locale, {
                style: 'currency',
                currency: currencyCode,
                currencyDisplay: 'symbol',
            }).formatToParts(123.45);
            this.hasFractionPart = !!parts.find(p => p.type === 'fraction');
            this._inputValue = this.toNumericString(this._inputValue);
        });
    }
    ngOnChanges(changes) {
        if ('value' in changes) {
            this.writeValue(changes['value'].currentValue);
        }
        if ('currencyCode' in changes) {
            this.currencyCode$.next(this.currencyCode);
        }
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouch = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    onInput(value) {
        const integerValue = Math.round(+value * this.currencyService.precisionFactor);
        if (typeof this.onChange === 'function') {
            this.onChange(integerValue);
        }
        this.valueChange.emit(integerValue);
        const delta = Math.abs(Number(this._inputValue) - Number(value));
        if (0.009 < delta && delta < 0.011) {
            this._inputValue = this.toNumericString(value);
        }
        else {
            this._inputValue = value;
        }
    }
    onFocus() {
        if (typeof this.onTouch === 'function') {
            this.onTouch();
        }
    }
    writeValue(value) {
        const numericValue = +value;
        if (!Number.isNaN(numericValue)) {
            this._inputValue = this.toNumericString(this.currencyService.toMajorUnits(Math.floor(value)));
        }
    }
    toNumericString(value) {
        return this.hasFractionPart ? Number(value).toFixed(this.precision) : Number(value).toFixed(0);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: CurrencyInputComponent, deps: [{ token: i1.DataService }, { token: i2.CurrencyService }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.4", type: CurrencyInputComponent, selector: "vdr-currency-input", inputs: { disabled: "disabled", readonly: "readonly", value: "value", currencyCode: "currencyCode" }, outputs: { valueChange: "valueChange" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: CurrencyInputComponent,
                multi: true,
            },
        ], usesOnChanges: true, ngImport: i0, template: "<vdr-affixed-input\r\n    [prefix]=\"prefix$ | async | localeCurrencyName: 'symbol'\"\r\n    [suffix]=\"suffix$ | async | localeCurrencyName: 'symbol'\"\r\n>\r\n    <input\r\n        type=\"number\"\r\n        [step]=\"hasFractionPart ? 1 / precisionFactor : 1\"\r\n        [value]=\"_inputValue\"\r\n        [disabled]=\"disabled\"\r\n        [readonly]=\"readonly\"\r\n        (input)=\"onInput($event.target.value)\"\r\n        (focus)=\"onFocus()\"\r\n    />\r\n</vdr-affixed-input>\r\n", styles: [":host{padding:0;border:none}:host.ng-invalid input[type=number]{color:var(--color-error-700);border-color:var(--color-error-300)}input[readonly]{background-color:transparent}\n"], dependencies: [{ kind: "component", type: i3.AffixedInputComponent, selector: "vdr-affixed-input", inputs: ["prefix", "suffix"] }, { kind: "directive", type: i4.FormFieldControlDirective, selector: "input, textarea, select, vdr-currency-input" }, { kind: "pipe", type: i5.AsyncPipe, name: "async" }, { kind: "pipe", type: i6.LocaleCurrencyNamePipe, name: "localeCurrencyName" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: CurrencyInputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-currency-input', providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: CurrencyInputComponent,
                            multi: true,
                        },
                    ], template: "<vdr-affixed-input\r\n    [prefix]=\"prefix$ | async | localeCurrencyName: 'symbol'\"\r\n    [suffix]=\"suffix$ | async | localeCurrencyName: 'symbol'\"\r\n>\r\n    <input\r\n        type=\"number\"\r\n        [step]=\"hasFractionPart ? 1 / precisionFactor : 1\"\r\n        [value]=\"_inputValue\"\r\n        [disabled]=\"disabled\"\r\n        [readonly]=\"readonly\"\r\n        (input)=\"onInput($event.target.value)\"\r\n        (focus)=\"onFocus()\"\r\n    />\r\n</vdr-affixed-input>\r\n", styles: [":host{padding:0;border:none}:host.ng-invalid input[type=number]{color:var(--color-error-700);border-color:var(--color-error-300)}input[readonly]{background-color:transparent}\n"] }]
        }], ctorParameters: () => [{ type: i1.DataService }, { type: i2.CurrencyService }], propDecorators: { disabled: [{
                type: Input
            }], readonly: [{
                type: Input
            }], value: [{
                type: Input
            }], currencyCode: [{
                type: Input
            }], valueChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VycmVuY3ktaW5wdXQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jb3JlL3NyYy9zaGFyZWQvY29tcG9uZW50cy9jdXJyZW5jeS1pbnB1dC9jdXJyZW5jeS1pbnB1dC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3NoYXJlZC9jb21wb25lbnRzL2N1cnJlbmN5LWlucHV0L2N1cnJlbmN5LWlucHV0LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCxTQUFTLEVBQ1QsWUFBWSxFQUNaLEtBQUssRUFJTCxNQUFNLEdBRVQsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxlQUFlLEVBQUUsYUFBYSxFQUE0QixNQUFNLE1BQU0sQ0FBQztBQUNoRixPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7Ozs7O0FBS3JDOzs7Ozs7Ozs7Ozs7OztHQWNHO0FBYUgsTUFBTSxPQUFPLHNCQUFzQjtJQWlCL0IsWUFBb0IsV0FBd0IsRUFBVSxlQUFnQztRQUFsRSxnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQUFVLG9CQUFlLEdBQWYsZUFBZSxDQUFpQjtRQWhCN0UsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUNqQixhQUFRLEdBQUcsS0FBSyxDQUFDO1FBRWpCLGlCQUFZLEdBQUcsRUFBRSxDQUFDO1FBQ2pCLGdCQUFXLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUczQyxvQkFBZSxHQUFHLElBQUksQ0FBQztRQUlmLGtCQUFhLEdBQUcsSUFBSSxlQUFlLENBQVMsRUFBRSxDQUFDLENBQUM7UUFNcEQsSUFBSSxDQUFDLFNBQVMsR0FBRyxlQUFlLENBQUMsU0FBUyxDQUFDO1FBQzNDLElBQUksQ0FBQyxl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QXNCLDRMQVJwQjtZQUNQO2dCQUNJLE9BQU8sRUFBRSxpQkFBaUI7Z0JBQzFCLFdBQVcsRUFBRSxzQkFBc0I7Z0JBQ25DLEtBQUssRUFBRSxJQUFJO2FBQ2Q7U0FDSiwrQ0MxQ0wsNGVBY0E7OzJGRDhCYSxzQkFBc0I7a0JBWmxDLFNBQVM7K0JBQ0ksb0JBQW9CLGFBR25CO3dCQUNQOzRCQUNJLE9BQU8sRUFBRSxpQkFBaUI7NEJBQzFCLFdBQVcsd0JBQXdCOzRCQUNuQyxLQUFLLEVBQUUsSUFBSTt5QkFDZDtxQkFDSjs4R0FHUSxRQUFRO3NCQUFoQixLQUFLO2dCQUNHLFFBQVE7c0JBQWhCLEtBQUs7Z0JBQ0csS0FBSztzQkFBYixLQUFLO2dCQUNHLFlBQVk7c0JBQXBCLEtBQUs7Z0JBQ0ksV0FBVztzQkFBcEIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgICBDb21wb25lbnQsXHJcbiAgICBFdmVudEVtaXR0ZXIsXHJcbiAgICBJbnB1dCxcclxuICAgIE9uQ2hhbmdlcyxcclxuICAgIE9uRGVzdHJveSxcclxuICAgIE9uSW5pdCxcclxuICAgIE91dHB1dCxcclxuICAgIFNpbXBsZUNoYW5nZXMsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBjb21iaW5lTGF0ZXN0LCBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5cclxuaW1wb3J0IHsgRGF0YVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9kYXRhL3Byb3ZpZGVycy9kYXRhLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBDdXJyZW5jeVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9wcm92aWRlcnMvY3VycmVuY3kvY3VycmVuY3kuc2VydmljZSc7XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEEgZm9ybSBpbnB1dCBjb250cm9sIHdoaWNoIGRpc3BsYXlzIGN1cnJlbmN5IGluIGRlY2ltYWwgZm9ybWF0LCB3aGlsc3Qgd29ya2luZ1xyXG4gKiB3aXRoIHRoZSBpbnRlZ2VyIGNlbnQgdmFsdWUgaW4gdGhlIGJhY2tncm91bmQuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYEhUTUxcclxuICogPHZkci1jdXJyZW5jeS1pbnB1dFxyXG4gKiAgICAgWyhuZ01vZGVsKV09XCJlbnRpdHlQcmljZVwiXHJcbiAqICAgICBbY3VycmVuY3lDb2RlXT1cImN1cnJlbmN5Q29kZVwiXHJcbiAqID48L3Zkci1jdXJyZW5jeS1pbnB1dD5cclxuICogYGBgXHJcbiAqXHJcbiAqIEBkb2NzQ2F0ZWdvcnkgY29tcG9uZW50c1xyXG4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3Zkci1jdXJyZW5jeS1pbnB1dCcsXHJcbiAgICB0ZW1wbGF0ZVVybDogJy4vY3VycmVuY3ktaW5wdXQuY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgc3R5bGVVcmxzOiBbJy4vY3VycmVuY3ktaW5wdXQuY29tcG9uZW50LnNjc3MnXSxcclxuICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXHJcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBDdXJyZW5jeUlucHV0Q29tcG9uZW50LFxyXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgXSxcclxufSlcclxuZXhwb3J0IGNsYXNzIEN1cnJlbmN5SW5wdXRDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XHJcbiAgICBASW5wdXQoKSBkaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgcmVhZG9ubHkgPSBmYWxzZTtcclxuICAgIEBJbnB1dCgpIHZhbHVlOiBudW1iZXI7XHJcbiAgICBASW5wdXQoKSBjdXJyZW5jeUNvZGUgPSAnJztcclxuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgIHByZWZpeCQ6IE9ic2VydmFibGU8c3RyaW5nPjtcclxuICAgIHN1ZmZpeCQ6IE9ic2VydmFibGU8c3RyaW5nPjtcclxuICAgIGhhc0ZyYWN0aW9uUGFydCA9IHRydWU7XHJcbiAgICBvbkNoYW5nZTogKHZhbDogYW55KSA9PiB2b2lkO1xyXG4gICAgb25Ub3VjaDogKCkgPT4gdm9pZDtcclxuICAgIF9pbnB1dFZhbHVlOiBzdHJpbmc7XHJcbiAgICBwcml2YXRlIGN1cnJlbmN5Q29kZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4oJycpO1xyXG4gICAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcclxuICAgIHJlYWRvbmx5IHByZWNpc2lvbjogbnVtYmVyO1xyXG4gICAgcmVhZG9ubHkgcHJlY2lzaW9uRmFjdG9yOiBudW1iZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhU2VydmljZTogRGF0YVNlcnZpY2UsIHByaXZhdGUgY3VycmVuY3lTZXJ2aWNlOiBDdXJyZW5jeVNlcnZpY2UpIHtcclxuICAgICAgICB0aGlzLnByZWNpc2lvbiA9IGN1cnJlbmN5U2VydmljZS5wcmVjaXNpb247XHJcbiAgICAgICAgdGhpcy5wcmVjaXNpb25GYWN0b3IgPSBjdXJyZW5jeVNlcnZpY2UucHJlY2lzaW9uRmFjdG9yO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIGNvbnN0IGxhbmd1YWdlQ29kZSQgPSB0aGlzLmRhdGFTZXJ2aWNlLmNsaWVudC51aVN0YXRlKCkubWFwU3RyZWFtKGRhdGEgPT4gZGF0YS51aVN0YXRlLmxhbmd1YWdlKTtcclxuICAgICAgICBjb25zdCBzaG91bGRQcmVmaXgkID0gY29tYmluZUxhdGVzdChsYW5ndWFnZUNvZGUkLCB0aGlzLmN1cnJlbmN5Q29kZSQpLnBpcGUoXHJcbiAgICAgICAgICAgIG1hcCgoW2xhbmd1YWdlQ29kZSwgY3VycmVuY3lDb2RlXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW5jeUNvZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGUgPSBsYW5ndWFnZUNvZGUucmVwbGFjZSgvXy9nLCAnLScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSAoXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2N1cnJlbmN5JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVuY3k6IGN1cnJlbmN5Q29kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVuY3lEaXNwbGF5OiAnc3ltYm9sJyxcclxuICAgICAgICAgICAgICAgICAgICB9KSBhcyBhbnlcclxuICAgICAgICAgICAgICAgICkuZm9ybWF0VG9QYXJ0cygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgTmFOU3RyaW5nID0gcGFydHMuZmluZChwID0+IHAudHlwZSA9PT0gJ25hbicpPy52YWx1ZSA/PyAnTmFOJztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsaXNlZCA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZTogJ2N1cnJlbmN5JyxcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW5jeTogY3VycmVuY3lDb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5RGlzcGxheTogJ3N5bWJvbCcsXHJcbiAgICAgICAgICAgICAgICB9KS5mb3JtYXQodW5kZWZpbmVkIGFzIGFueSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxpc2VkLmluZGV4T2YoTmFOU3RyaW5nKSA+IDA7XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5wcmVmaXgkID0gc2hvdWxkUHJlZml4JC5waXBlKG1hcChzaG91bGRQcmVmaXggPT4gKHNob3VsZFByZWZpeCA/IHRoaXMuY3VycmVuY3lDb2RlIDogJycpKSk7XHJcbiAgICAgICAgdGhpcy5zdWZmaXgkID0gc2hvdWxkUHJlZml4JC5waXBlKG1hcChzaG91bGRQcmVmaXggPT4gKHNob3VsZFByZWZpeCA/ICcnIDogdGhpcy5jdXJyZW5jeUNvZGUpKSk7XHJcblxyXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gY29tYmluZUxhdGVzdChsYW5ndWFnZUNvZGUkLCB0aGlzLmN1cnJlbmN5Q29kZSQpLnN1YnNjcmliZShcclxuICAgICAgICAgICAgKFtsYW5ndWFnZUNvZGUsIGN1cnJlbmN5Q29kZV0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghY3VycmVuY3lDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlID0gbGFuZ3VhZ2VDb2RlLnJlcGxhY2UoL18vZywgJy0nKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gKFxyXG4gICAgICAgICAgICAgICAgICAgIG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6ICdjdXJyZW5jeScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5OiBjdXJyZW5jeUNvZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbmN5RGlzcGxheTogJ3N5bWJvbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgfSkgYXMgYW55XHJcbiAgICAgICAgICAgICAgICApLmZvcm1hdFRvUGFydHMoMTIzLjQ1KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFzRnJhY3Rpb25QYXJ0ID0gISFwYXJ0cy5maW5kKHAgPT4gcC50eXBlID09PSAnZnJhY3Rpb24nKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0VmFsdWUgPSB0aGlzLnRvTnVtZXJpY1N0cmluZyh0aGlzLl9pbnB1dFZhbHVlKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcclxuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZShjaGFuZ2VzWyd2YWx1ZSddLmN1cnJlbnRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgnY3VycmVuY3lDb2RlJyBpbiBjaGFuZ2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVuY3lDb2RlJC5uZXh0KHRoaXMuY3VycmVuY3lDb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KSB7XHJcbiAgICAgICAgdGhpcy5vblRvdWNoID0gZm47XHJcbiAgICB9XHJcblxyXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgb25JbnB1dCh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgaW50ZWdlclZhbHVlID0gTWF0aC5yb3VuZCgrdmFsdWUgKiB0aGlzLmN1cnJlbmN5U2VydmljZS5wcmVjaXNpb25GYWN0b3IpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKGludGVnZXJWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdChpbnRlZ2VyVmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IGRlbHRhID0gTWF0aC5hYnMoTnVtYmVyKHRoaXMuX2lucHV0VmFsdWUpIC0gTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgaWYgKDAuMDA5IDwgZGVsdGEgJiYgZGVsdGEgPCAwLjAxMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnB1dFZhbHVlID0gdGhpcy50b051bWVyaWNTdHJpbmcodmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lucHV0VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25Gb2N1cygpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub25Ub3VjaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLm9uVG91Y2goKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgbnVtZXJpY1ZhbHVlID0gK3ZhbHVlO1xyXG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKG51bWVyaWNWYWx1ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5wdXRWYWx1ZSA9IHRoaXMudG9OdW1lcmljU3RyaW5nKHRoaXMuY3VycmVuY3lTZXJ2aWNlLnRvTWFqb3JVbml0cyhNYXRoLmZsb29yKHZhbHVlKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHRvTnVtZXJpY1N0cmluZyh2YWx1ZTogbnVtYmVyIHwgc3RyaW5nKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oYXNGcmFjdGlvblBhcnQgPyBOdW1iZXIodmFsdWUpLnRvRml4ZWQodGhpcy5wcmVjaXNpb24pIDogTnVtYmVyKHZhbHVlKS50b0ZpeGVkKDApO1xyXG4gICAgfVxyXG59XHJcbiIsIjx2ZHItYWZmaXhlZC1pbnB1dFxyXG4gICAgW3ByZWZpeF09XCJwcmVmaXgkIHwgYXN5bmMgfCBsb2NhbGVDdXJyZW5jeU5hbWU6ICdzeW1ib2wnXCJcclxuICAgIFtzdWZmaXhdPVwic3VmZml4JCB8IGFzeW5jIHwgbG9jYWxlQ3VycmVuY3lOYW1lOiAnc3ltYm9sJ1wiXHJcbj5cclxuICAgIDxpbnB1dFxyXG4gICAgICAgIHR5cGU9XCJudW1iZXJcIlxyXG4gICAgICAgIFtzdGVwXT1cImhhc0ZyYWN0aW9uUGFydCA/IDEgLyBwcmVjaXNpb25GYWN0b3IgOiAxXCJcclxuICAgICAgICBbdmFsdWVdPVwiX2lucHV0VmFsdWVcIlxyXG4gICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXHJcbiAgICAgICAgW3JlYWRvbmx5XT1cInJlYWRvbmx5XCJcclxuICAgICAgICAoaW5wdXQpPVwib25JbnB1dCgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXHJcbiAgICAgICAgKGZvY3VzKT1cIm9uRm9jdXMoKVwiXHJcbiAgICAvPlxyXG48L3Zkci1hZmZpeGVkLWlucHV0PlxyXG4iXX0=