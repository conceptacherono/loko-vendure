import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, ViewChild, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NgSelectComponent } from '@ng-select/ng-select';
import { gql } from 'apollo-angular';
import { Subject } from 'rxjs';
import { GetZoneSelectorListDocument } from '../../../common/generated-types';
import * as i0 from "@angular/core";
import * as i1 from "../../../data/providers/data.service";
import * as i2 from "@angular/forms";
import * as i3 from "@ng-select/ng-select";
import * as i4 from "@angular/common";
export const GET_ZONE_SELECTOR_LIST = gql `
    query GetZoneSelectorList($options: ZoneListOptions) {
        zones(options: $options) {
            items {
                id
                createdAt
                updatedAt
                name
            }
            totalItems
        }
    }
`;
/**
 * @description
 * A form control for selecting zones.
 *
 * @docsCategory components
 */
export class ZoneSelectorComponent {
    constructor(dataService, changeDetectorRef) {
        this.dataService = dataService;
        this.changeDetectorRef = changeDetectorRef;
        this.selectedValuesChange = new EventEmitter();
        this.readonly = false;
        this.transformControlValueAccessorValue = value => value?.id;
        this.selectedId$ = new Subject();
        this.disabled = false;
        this.zones$ = this.dataService
            .query(GetZoneSelectorListDocument, { options: { take: 999 } })
            .mapSingle(result => result.zones.items);
    }
    onChange(selected) {
        if (this.readonly) {
            return;
        }
        this.selectedValuesChange.emit(selected);
        if (this.onChangeFn) {
            const transformedValue = this.transformControlValueAccessorValue(selected);
            this.onChangeFn(transformedValue);
        }
    }
    registerOnChange(fn) {
        this.onChangeFn = fn;
    }
    registerOnTouched(fn) {
        this.onTouchFn = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    focus() {
        this.ngSelect.focus();
    }
    writeValue(obj) {
        if (typeof obj === 'string' && obj.length > 0) {
            this.value = obj;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: ZoneSelectorComponent, deps: [{ token: i1.DataService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.4", type: ZoneSelectorComponent, selector: "vdr-zone-selector", inputs: { readonly: "readonly", transformControlValueAccessorValue: "transformControlValueAccessorValue" }, outputs: { selectedValuesChange: "selectedValuesChange" }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: ZoneSelectorComponent,
                multi: true,
            },
        ], viewQueries: [{ propertyName: "ngSelect", first: true, predicate: NgSelectComponent, descendants: true }], ngImport: i0, template: "<ng-select\r\n    [items]=\"zones$ | async\"\r\n    [addTag]=\"false\"\r\n    appendTo=\"body\"\r\n    bindLabel=\"name\"\r\n    bindValue=\"id\"\r\n    [disabled]=\"disabled || readonly\"\r\n    [ngModel]=\"value\"\r\n    (change)=\"onChange($event)\"\r\n>\r\n</ng-select>\r\n", styles: [""], dependencies: [{ kind: "directive", type: i2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: i3.NgSelectComponent, selector: "ng-select", inputs: ["bindLabel", "bindValue", "markFirst", "placeholder", "notFoundText", "typeToSearchText", "addTagText", "loadingText", "clearAllText", "appearance", "dropdownPosition", "appendTo", "loading", "closeOnSelect", "hideSelected", "selectOnTab", "openOnEnter", "maxSelectedItems", "groupBy", "groupValue", "bufferAmount", "virtualScroll", "selectableGroup", "selectableGroupAsModel", "searchFn", "trackByFn", "clearOnBackspace", "labelForId", "inputAttrs", "tabIndex", "readonly", "searchWhileComposing", "minTermLength", "editableSearchTerm", "keyDownFn", "typeahead", "multiple", "addTag", "searchable", "clearable", "isOpen", "items", "compareWith", "clearSearchOnAdd", "deselectOnClick"], outputs: ["blur", "focus", "change", "open", "close", "search", "clear", "add", "remove", "scroll", "scrollToEnd"] }, { kind: "pipe", type: i4.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: ZoneSelectorComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-zone-selector', changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: ZoneSelectorComponent,
                            multi: true,
                        },
                    ], template: "<ng-select\r\n    [items]=\"zones$ | async\"\r\n    [addTag]=\"false\"\r\n    appendTo=\"body\"\r\n    bindLabel=\"name\"\r\n    bindValue=\"id\"\r\n    [disabled]=\"disabled || readonly\"\r\n    [ngModel]=\"value\"\r\n    (change)=\"onChange($event)\"\r\n>\r\n</ng-select>\r\n" }]
        }], ctorParameters: () => [{ type: i1.DataService }, { type: i0.ChangeDetectorRef }], propDecorators: { selectedValuesChange: [{
                type: Output
            }], readonly: [{
                type: Input
            }], transformControlValueAccessorValue: [{
                type: Input
            }], ngSelect: [{
                type: ViewChild,
                args: [NgSelectComponent]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiem9uZS1zZWxlY3Rvci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3NoYXJlZC9jb21wb25lbnRzL3pvbmUtc2VsZWN0b3Ivem9uZS1zZWxlY3Rvci5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9zcmMvbGliL2NvcmUvc3JjL3NoYXJlZC9jb21wb25lbnRzL3pvbmUtc2VsZWN0b3Ivem9uZS1zZWxlY3Rvci5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0gsdUJBQXVCLEVBRXZCLFNBQVMsRUFDVCxZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFDTixTQUFTLEdBQ1osTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQ3pELE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRS9CLE9BQU8sRUFBRSwyQkFBMkIsRUFBNEIsTUFBTSxpQ0FBaUMsQ0FBQzs7Ozs7O0FBR3hHLE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFHLEdBQUcsQ0FBQTs7Ozs7Ozs7Ozs7O0NBWXhDLENBQUM7QUFJRjs7Ozs7R0FLRztBQWNILE1BQU0sT0FBTyxxQkFBcUI7SUFnQjlCLFlBQ1ksV0FBd0IsRUFDeEIsaUJBQW9DO1FBRHBDLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQ3hCLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7UUFqQnRDLHlCQUFvQixHQUFHLElBQUksWUFBWSxFQUFRLENBQUM7UUFDakQsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUNqQix1Q0FBa0MsR0FBcUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDO1FBQ25HLGdCQUFXLEdBQUcsSUFBSSxPQUFPLEVBQVUsQ0FBQztRQU1wQyxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBRWpCLFdBQU0sR0FBRyxJQUFJLENBQUMsV0FBVzthQUNwQixLQUFLLENBQUMsMkJBQTJCLEVBQUUsRUFBRSxPQUFPLEVBQUUsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLEVBQUUsQ0FBQzthQUM5RCxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBSzFDLENBQUM7SUFFSixRQUFRLENBQUMsUUFBYztRQUNuQixJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNoQixPQUFPO1FBQ1gsQ0FBQztRQUNELElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDekMsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDbEIsTUFBTSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsa0NBQWtDLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDM0UsSUFBSSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ3RDLENBQUM7SUFDTCxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsRUFBTztRQUNwQixJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQsaUJBQWlCLENBQUMsRUFBTztRQUNyQixJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRUQsZ0JBQWdCLENBQUMsVUFBbUI7UUFDaEMsSUFBSSxDQUFDLFFBQVEsR0FBRyxVQUFVLENBQUM7SUFDL0IsQ0FBQztJQUVELEtBQUs7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQzFCLENBQUM7SUFFRCxVQUFVLENBQUMsR0FBeUI7UUFDaEMsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLElBQUksR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUM1QyxJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztRQUNyQixDQUFDO0lBQ0wsQ0FBQzs4R0FwRFEscUJBQXFCO2tHQUFyQixxQkFBcUIsbU5BUm5CO1lBQ1A7Z0JBQ0ksT0FBTyxFQUFFLGlCQUFpQjtnQkFDMUIsV0FBVyxFQUFFLHFCQUFxQjtnQkFDbEMsS0FBSyxFQUFFLElBQUk7YUFDZDtTQUNKLG9FQVFVLGlCQUFpQixnREMxRGhDLHVSQVdBOzsyRkR5Q2EscUJBQXFCO2tCQWJqQyxTQUFTOytCQUNJLG1CQUFtQixtQkFHWix1QkFBdUIsQ0FBQyxNQUFNLGFBQ3BDO3dCQUNQOzRCQUNJLE9BQU8sRUFBRSxpQkFBaUI7NEJBQzFCLFdBQVcsdUJBQXVCOzRCQUNsQyxLQUFLLEVBQUUsSUFBSTt5QkFDZDtxQkFDSjtnSEFHUyxvQkFBb0I7c0JBQTdCLE1BQU07Z0JBQ0UsUUFBUTtzQkFBaEIsS0FBSztnQkFDRyxrQ0FBa0M7c0JBQTFDLEtBQUs7Z0JBR2dDLFFBQVE7c0JBQTdDLFNBQVM7dUJBQUMsaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICBDb21wb25lbnQsXHJcbiAgICBFdmVudEVtaXR0ZXIsXHJcbiAgICBJbnB1dCxcclxuICAgIE91dHB1dCxcclxuICAgIFZpZXdDaGlsZCxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBOZ1NlbGVjdENvbXBvbmVudCB9IGZyb20gJ0BuZy1zZWxlY3Qvbmctc2VsZWN0JztcclxuaW1wb3J0IHsgZ3FsIH0gZnJvbSAnYXBvbGxvLWFuZ3VsYXInO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IEl0ZW1PZiB9IGZyb20gJy4uLy4uLy4uL2NvbW1vbi9iYXNlLWxpc3QuY29tcG9uZW50JztcclxuaW1wb3J0IHsgR2V0Wm9uZVNlbGVjdG9yTGlzdERvY3VtZW50LCBHZXRab25lU2VsZWN0b3JMaXN0UXVlcnkgfSBmcm9tICcuLi8uLi8uLi9jb21tb24vZ2VuZXJhdGVkLXR5cGVzJztcclxuaW1wb3J0IHsgRGF0YVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9kYXRhL3Byb3ZpZGVycy9kYXRhLnNlcnZpY2UnO1xyXG5cclxuZXhwb3J0IGNvbnN0IEdFVF9aT05FX1NFTEVDVE9SX0xJU1QgPSBncWxgXHJcbiAgICBxdWVyeSBHZXRab25lU2VsZWN0b3JMaXN0KCRvcHRpb25zOiBab25lTGlzdE9wdGlvbnMpIHtcclxuICAgICAgICB6b25lcyhvcHRpb25zOiAkb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpdGVtcyB7XHJcbiAgICAgICAgICAgICAgICBpZFxyXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkQXRcclxuICAgICAgICAgICAgICAgIG5hbWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b3RhbEl0ZW1zXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5gO1xyXG5cclxudHlwZSBab25lID0gSXRlbU9mPEdldFpvbmVTZWxlY3Rvckxpc3RRdWVyeSwgJ3pvbmVzJz47XHJcblxyXG4vKipcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEEgZm9ybSBjb250cm9sIGZvciBzZWxlY3Rpbmcgem9uZXMuXHJcbiAqXHJcbiAqIEBkb2NzQ2F0ZWdvcnkgY29tcG9uZW50c1xyXG4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3Zkci16b25lLXNlbGVjdG9yJyxcclxuICAgIHRlbXBsYXRlVXJsOiAnLi96b25lLXNlbGVjdG9yLmNvbXBvbmVudC5odG1sJyxcclxuICAgIHN0eWxlVXJsczogWycuL3pvbmUtc2VsZWN0b3IuY29tcG9uZW50LnNjc3MnXSxcclxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG4gICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcclxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IFpvbmVTZWxlY3RvckNvbXBvbmVudCxcclxuICAgICAgICAgICAgbXVsdGk6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgIF0sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBab25lU2VsZWN0b3JDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XHJcbiAgICBAT3V0cHV0KCkgc2VsZWN0ZWRWYWx1ZXNDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPFpvbmU+KCk7XHJcbiAgICBASW5wdXQoKSByZWFkb25seSA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgdHJhbnNmb3JtQ29udHJvbFZhbHVlQWNjZXNzb3JWYWx1ZTogKHZhbHVlOiBab25lIHwgdW5kZWZpbmVkKSA9PiBhbnkgPSB2YWx1ZSA9PiB2YWx1ZT8uaWQ7XHJcbiAgICBzZWxlY3RlZElkJCA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcclxuXHJcbiAgICBAVmlld0NoaWxkKE5nU2VsZWN0Q29tcG9uZW50KSBwcml2YXRlIG5nU2VsZWN0OiBOZ1NlbGVjdENvbXBvbmVudDtcclxuXHJcbiAgICBvbkNoYW5nZUZuOiAodmFsOiBhbnkpID0+IHZvaWQ7XHJcbiAgICBvblRvdWNoRm46ICgpID0+IHZvaWQ7XHJcbiAgICBkaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgdmFsdWU6IHN0cmluZyB8IFpvbmU7XHJcbiAgICB6b25lcyQgPSB0aGlzLmRhdGFTZXJ2aWNlXHJcbiAgICAgICAgLnF1ZXJ5KEdldFpvbmVTZWxlY3Rvckxpc3REb2N1bWVudCwgeyBvcHRpb25zOiB7IHRha2U6IDk5OSB9IH0pXHJcbiAgICAgICAgLm1hcFNpbmdsZShyZXN1bHQgPT4gcmVzdWx0LnpvbmVzLml0ZW1zKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIGRhdGFTZXJ2aWNlOiBEYXRhU2VydmljZSxcclxuICAgICAgICBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcclxuICAgICkge31cclxuXHJcbiAgICBvbkNoYW5nZShzZWxlY3RlZDogWm9uZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRvbmx5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlc0NoYW5nZS5lbWl0KHNlbGVjdGVkKTtcclxuICAgICAgICBpZiAodGhpcy5vbkNoYW5nZUZuKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVmFsdWUgPSB0aGlzLnRyYW5zZm9ybUNvbnRyb2xWYWx1ZUFjY2Vzc29yVmFsdWUoc2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hhbmdlRm4odHJhbnNmb3JtZWRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2VGbiA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpIHtcclxuICAgICAgICB0aGlzLm9uVG91Y2hGbiA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZvY3VzKCkge1xyXG4gICAgICAgIHRoaXMubmdTZWxlY3QuZm9jdXMoKTtcclxuICAgIH1cclxuXHJcbiAgICB3cml0ZVZhbHVlKG9iajogc3RyaW5nIHwgWm9uZSB8IG51bGwpOiB2b2lkIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycgJiYgb2JqLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9iajtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiPG5nLXNlbGVjdFxyXG4gICAgW2l0ZW1zXT1cInpvbmVzJCB8IGFzeW5jXCJcclxuICAgIFthZGRUYWddPVwiZmFsc2VcIlxyXG4gICAgYXBwZW5kVG89XCJib2R5XCJcclxuICAgIGJpbmRMYWJlbD1cIm5hbWVcIlxyXG4gICAgYmluZFZhbHVlPVwiaWRcIlxyXG4gICAgW2Rpc2FibGVkXT1cImRpc2FibGVkIHx8IHJlYWRvbmx5XCJcclxuICAgIFtuZ01vZGVsXT1cInZhbHVlXCJcclxuICAgIChjaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiXHJcbj5cclxuPC9uZy1zZWxlY3Q+XHJcbiJdfQ==