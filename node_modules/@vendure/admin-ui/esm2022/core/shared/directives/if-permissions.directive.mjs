import { Directive, Input } from '@angular/core';
import { of } from 'rxjs';
import { map, tap } from 'rxjs/operators';
import { IfDirectiveBase } from './if-directive-base';
import * as i0 from "@angular/core";
import * as i1 from "../../providers/permissions/permissions.service";
/**
 * @description
 * Conditionally shows/hides templates based on the current active user having the specified permission.
 * Based on the ngIf source. Also support "else" templates:
 *
 * @example
 * ```html
 * <button *vdrIfPermissions="'DeleteCatalog'; else unauthorized">Delete Product</button>
 * <ng-template #unauthorized>Not allowed!</ng-template>
 * ```
 *
 * The permission can be a single string, or an array. If an array is passed, then _all_ of the permissions
 * must match (logical AND)
 *
 * @docsCategory directives
 */
export class IfPermissionsDirective extends IfDirectiveBase {
    constructor(_viewContainer, templateRef, changeDetectorRef, permissionsService) {
        super(_viewContainer, templateRef, permissions => {
            if (permissions == null) {
                return of(true);
            }
            else if (!permissions) {
                return of(false);
            }
            return this.permissionsService.currentUserPermissions$.pipe(map(() => this.permissionsService.userHasPermissions(permissions)), tap(() => this.changeDetectorRef.markForCheck()));
        });
        this.changeDetectorRef = changeDetectorRef;
        this.permissionsService = permissionsService;
        this.permissionToCheck = ['__initial_value__'];
    }
    /**
     * The permission to check to determine whether to show the template.
     */
    set vdrIfPermissions(permission) {
        this.permissionToCheck =
            (permission && (Array.isArray(permission) ? permission : [permission])) || null;
        this.updateArgs$.next([this.permissionToCheck]);
    }
    /**
     * A template to show if the current user does not have the specified permission.
     */
    set vdrIfPermissionsElse(templateRef) {
        this.setElseTemplate(templateRef);
        this.updateArgs$.next([this.permissionToCheck]);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IfPermissionsDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: i0.ChangeDetectorRef }, { token: i1.PermissionsService }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "17.2.4", type: IfPermissionsDirective, selector: "[vdrIfPermissions]", inputs: { vdrIfPermissions: "vdrIfPermissions", vdrIfPermissionsElse: "vdrIfPermissionsElse" }, usesInheritance: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: IfPermissionsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[vdrIfPermissions]',
                }]
        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: i0.ChangeDetectorRef }, { type: i1.PermissionsService }], propDecorators: { vdrIfPermissions: [{
                type: Input
            }], vdrIfPermissionsElse: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWYtcGVybWlzc2lvbnMuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9jb3JlL3NyYy9zaGFyZWQvZGlyZWN0aXZlcy9pZi1wZXJtaXNzaW9ucy5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFxQixTQUFTLEVBQUUsS0FBSyxFQUFpQyxNQUFNLGVBQWUsQ0FBQztBQUNuRyxPQUFPLEVBQUUsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzFCLE9BQU8sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFLMUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHFCQUFxQixDQUFDOzs7QUFFdEQ7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBSUgsTUFBTSxPQUFPLHNCQUF1QixTQUFRLGVBQTJDO0lBR25GLFlBQ0ksY0FBZ0MsRUFDaEMsV0FBNkIsRUFDckIsaUJBQW9DLEVBQ3BDLGtCQUFzQztRQUU5QyxLQUFLLENBQUMsY0FBYyxFQUFFLFdBQVcsRUFBRSxXQUFXLENBQUMsRUFBRTtZQUM3QyxJQUFJLFdBQVcsSUFBSSxJQUFJLEVBQUUsQ0FBQztnQkFDdEIsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDcEIsQ0FBQztpQkFBTSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7Z0JBQ3RCLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3JCLENBQUM7WUFDRCxPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQ3ZELEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsa0JBQWtCLENBQUMsV0FBVyxDQUFDLENBQUMsRUFDbEUsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUNuRCxDQUFDO1FBQ04sQ0FBQyxDQUFDLENBQUM7UUFiSyxzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO1FBQ3BDLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBb0I7UUFOMUMsc0JBQWlCLEdBQW9CLENBQUMsbUJBQW1CLENBQUMsQ0FBQztJQW1CbkUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFDSSxnQkFBZ0IsQ0FBQyxVQUFvQztRQUNyRCxJQUFJLENBQUMsaUJBQWlCO1lBQ2xCLENBQUMsVUFBVSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUM7UUFDcEYsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlDLENBQUMsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFRDs7T0FFRztJQUNILElBQ0ksb0JBQW9CLENBQUMsV0FBb0M7UUFDekQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUMsQ0FBQyxDQUFDLENBQUM7SUFDcEUsQ0FBQzs4R0F2Q1Esc0JBQXNCO2tHQUF0QixzQkFBc0I7OzJGQUF0QixzQkFBc0I7a0JBSGxDLFNBQVM7bUJBQUM7b0JBQ1AsUUFBUSxFQUFFLG9CQUFvQjtpQkFDakM7Z0xBMkJPLGdCQUFnQjtzQkFEbkIsS0FBSztnQkFXRixvQkFBb0I7c0JBRHZCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgRGlyZWN0aXZlLCBJbnB1dCwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgbWFwLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5pbXBvcnQgeyBQZXJtaXNzaW9uIH0gZnJvbSAnLi4vLi4vY29tbW9uL2dlbmVyYXRlZC10eXBlcyc7XHJcbmltcG9ydCB7IFBlcm1pc3Npb25zU2VydmljZSB9IGZyb20gJy4uLy4uL3Byb3ZpZGVycy9wZXJtaXNzaW9ucy9wZXJtaXNzaW9ucy5zZXJ2aWNlJztcclxuXHJcbmltcG9ydCB7IElmRGlyZWN0aXZlQmFzZSB9IGZyb20gJy4vaWYtZGlyZWN0aXZlLWJhc2UnO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvblxyXG4gKiBDb25kaXRpb25hbGx5IHNob3dzL2hpZGVzIHRlbXBsYXRlcyBiYXNlZCBvbiB0aGUgY3VycmVudCBhY3RpdmUgdXNlciBoYXZpbmcgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uLlxyXG4gKiBCYXNlZCBvbiB0aGUgbmdJZiBzb3VyY2UuIEFsc28gc3VwcG9ydCBcImVsc2VcIiB0ZW1wbGF0ZXM6XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGh0bWxcclxuICogPGJ1dHRvbiAqdmRySWZQZXJtaXNzaW9ucz1cIidEZWxldGVDYXRhbG9nJzsgZWxzZSB1bmF1dGhvcml6ZWRcIj5EZWxldGUgUHJvZHVjdDwvYnV0dG9uPlxyXG4gKiA8bmctdGVtcGxhdGUgI3VuYXV0aG9yaXplZD5Ob3QgYWxsb3dlZCE8L25nLXRlbXBsYXRlPlxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIHBlcm1pc3Npb24gY2FuIGJlIGEgc2luZ2xlIHN0cmluZywgb3IgYW4gYXJyYXkuIElmIGFuIGFycmF5IGlzIHBhc3NlZCwgdGhlbiBfYWxsXyBvZiB0aGUgcGVybWlzc2lvbnNcclxuICogbXVzdCBtYXRjaCAobG9naWNhbCBBTkQpXHJcbiAqXHJcbiAqIEBkb2NzQ2F0ZWdvcnkgZGlyZWN0aXZlc1xyXG4gKi9cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1t2ZHJJZlBlcm1pc3Npb25zXScsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBJZlBlcm1pc3Npb25zRGlyZWN0aXZlIGV4dGVuZHMgSWZEaXJlY3RpdmVCYXNlPEFycmF5PFBlcm1pc3Npb25bXSB8IG51bGw+PiB7XHJcbiAgICBwcml2YXRlIHBlcm1pc3Npb25Ub0NoZWNrOiBzdHJpbmdbXSB8IG51bGwgPSBbJ19faW5pdGlhbF92YWx1ZV9fJ107XHJcblxyXG4gICAgY29uc3RydWN0b3IoXHJcbiAgICAgICAgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXHJcbiAgICAgICAgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sXHJcbiAgICAgICAgcHJpdmF0ZSBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICAgICAgcHJpdmF0ZSBwZXJtaXNzaW9uc1NlcnZpY2U6IFBlcm1pc3Npb25zU2VydmljZSxcclxuICAgICkge1xyXG4gICAgICAgIHN1cGVyKF92aWV3Q29udGFpbmVyLCB0ZW1wbGF0ZVJlZiwgcGVybWlzc2lvbnMgPT4ge1xyXG4gICAgICAgICAgICBpZiAocGVybWlzc2lvbnMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKHRydWUpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFwZXJtaXNzaW9ucykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJtaXNzaW9uc1NlcnZpY2UuY3VycmVudFVzZXJQZXJtaXNzaW9ucyQucGlwZShcclxuICAgICAgICAgICAgICAgIG1hcCgoKSA9PiB0aGlzLnBlcm1pc3Npb25zU2VydmljZS51c2VySGFzUGVybWlzc2lvbnMocGVybWlzc2lvbnMpKSxcclxuICAgICAgICAgICAgICAgIHRhcCgoKSA9PiB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwZXJtaXNzaW9uIHRvIGNoZWNrIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHNob3cgdGhlIHRlbXBsYXRlLlxyXG4gICAgICovXHJcbiAgICBASW5wdXQoKVxyXG4gICAgc2V0IHZkcklmUGVybWlzc2lvbnMocGVybWlzc2lvbjogc3RyaW5nIHwgc3RyaW5nW10gfCBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5wZXJtaXNzaW9uVG9DaGVjayA9XHJcbiAgICAgICAgICAgIChwZXJtaXNzaW9uICYmIChBcnJheS5pc0FycmF5KHBlcm1pc3Npb24pID8gcGVybWlzc2lvbiA6IFtwZXJtaXNzaW9uXSkpIHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy51cGRhdGVBcmdzJC5uZXh0KFt0aGlzLnBlcm1pc3Npb25Ub0NoZWNrIGFzIFBlcm1pc3Npb25bXV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQSB0ZW1wbGF0ZSB0byBzaG93IGlmIHRoZSBjdXJyZW50IHVzZXIgZG9lcyBub3QgaGF2ZSB0aGUgc3BlY2lmaWVkIHBlcm1pc3Npb24uXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpXHJcbiAgICBzZXQgdmRySWZQZXJtaXNzaW9uc0Vsc2UodGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4gfCBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5zZXRFbHNlVGVtcGxhdGUodGVtcGxhdGVSZWYpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQXJncyQubmV4dChbdGhpcy5wZXJtaXNzaW9uVG9DaGVjayBhcyBQZXJtaXNzaW9uW11dKTtcclxuICAgIH1cclxufVxyXG4iXX0=