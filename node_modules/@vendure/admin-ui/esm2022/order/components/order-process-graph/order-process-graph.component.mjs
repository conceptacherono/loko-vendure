import { ChangeDetectionStrategy, Component, HostBinding, Input, ViewChildren, } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
import { NODE_HEIGHT } from './constants';
import { OrderProcessNodeComponent } from './order-process-node.component';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "./order-process-node.component";
import * as i3 from "./order-process-edge.component";
export class OrderProcessGraphComponent {
    constructor(changeDetector) {
        this.changeDetector = changeDetector;
        this.setActiveState$ = new BehaviorSubject(undefined);
        this.nodes = [];
        this.edges = [];
    }
    get outerHeight() {
        return this.nodes.length * NODE_HEIGHT;
    }
    ngOnInit() {
        this.setActiveState$.next(this.initialState);
        this.activeState$ = this.setActiveState$.pipe(debounceTime(150));
    }
    ngOnChanges(changes) {
        this.populateNodes();
    }
    ngAfterViewInit() {
        setTimeout(() => this.populateEdges());
    }
    onMouseOver(stateName) {
        this.setActiveState$.next(stateName);
    }
    onMouseOut() {
        this.setActiveState$.next(this.initialState);
    }
    getNodeFor(state) {
        if (this.nodeComponents) {
            return this.nodeComponents.find((n) => n.node.name === state);
        }
    }
    populateNodes() {
        const stateNodeMap = new Map();
        for (const state of this.states) {
            stateNodeMap.set(state.name, {
                name: state.name,
                to: [],
            });
        }
        for (const [name, stateNode] of stateNodeMap.entries()) {
            const targets = this.states.find((s) => s.name === name)?.to ?? [];
            for (const target of targets) {
                const targetNode = stateNodeMap.get(target);
                if (targetNode) {
                    stateNode.to.push(targetNode);
                }
            }
        }
        this.nodes = [...stateNodeMap.values()].filter((n) => n.name !== 'Cancelled');
    }
    populateEdges() {
        for (const node of this.nodes) {
            const nodeCmp = this.getNodeFor(node.name);
            let index = 0;
            for (const to of node.to) {
                const toCmp = this.getNodeFor(to.name);
                if (nodeCmp && toCmp && nodeCmp !== toCmp) {
                    this.edges.push({
                        to: toCmp,
                        from: nodeCmp,
                        index,
                    });
                    index++;
                }
            }
        }
        this.edges = [...this.edges];
        this.changeDetector.markForCheck();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: OrderProcessGraphComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.4", type: OrderProcessGraphComponent, selector: "vdr-order-process-graph", inputs: { states: "states", initialState: "initialState" }, host: { properties: { "style.height.px": "this.outerHeight" } }, viewQueries: [{ propertyName: "nodeComponents", predicate: OrderProcessNodeComponent, descendants: true }], usesOnChanges: true, ngImport: i0, template: "<ng-container *ngFor=\"let state of nodes; let i = index\">\r\n    <vdr-order-process-node\r\n        [node]=\"state\"\r\n        [index]=\"i\"\r\n        [active]=\"(activeState$ | async) === state.name\"\r\n        (mouseenter)=\"onMouseOver(state.name)\"\r\n        (mouseleave)=\"onMouseOut()\"\r\n    ></vdr-order-process-node>\r\n</ng-container>\r\n<ng-container *ngFor=\"let edge of edges\">\r\n    <vdr-order-process-edge [from]=\"edge.from\" [to]=\"edge.to\" [index]=\"edge.index\"></vdr-order-process-edge>\r\n</ng-container>\r\n", styles: [":host{display:block;border:1px hotpink;margin:20px;padding:12px;position:relative}.state-row{display:flex}\n"], dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: i2.OrderProcessNodeComponent, selector: "vdr-order-process-node", inputs: ["node", "index", "active"] }, { kind: "component", type: i3.OrderProcessEdgeComponent, selector: "vdr-order-process-edge", inputs: ["from", "to", "index"] }, { kind: "pipe", type: i1.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: OrderProcessGraphComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-order-process-graph', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container *ngFor=\"let state of nodes; let i = index\">\r\n    <vdr-order-process-node\r\n        [node]=\"state\"\r\n        [index]=\"i\"\r\n        [active]=\"(activeState$ | async) === state.name\"\r\n        (mouseenter)=\"onMouseOver(state.name)\"\r\n        (mouseleave)=\"onMouseOut()\"\r\n    ></vdr-order-process-node>\r\n</ng-container>\r\n<ng-container *ngFor=\"let edge of edges\">\r\n    <vdr-order-process-edge [from]=\"edge.from\" [to]=\"edge.to\" [index]=\"edge.index\"></vdr-order-process-edge>\r\n</ng-container>\r\n", styles: [":host{display:block;border:1px hotpink;margin:20px;padding:12px;position:relative}.state-row{display:flex}\n"] }]
        }], ctorParameters: () => [{ type: i0.ChangeDetectorRef }], propDecorators: { states: [{
                type: Input
            }], initialState: [{
                type: Input
            }], nodeComponents: [{
                type: ViewChildren,
                args: [OrderProcessNodeComponent]
            }], outerHeight: [{
                type: HostBinding,
                args: ['style.height.px']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3JkZXItcHJvY2Vzcy1ncmFwaC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL29yZGVyL3NyYy9jb21wb25lbnRzL29yZGVyLXByb2Nlc3MtZ3JhcGgvb3JkZXItcHJvY2Vzcy1ncmFwaC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL29yZGVyL3NyYy9jb21wb25lbnRzL29yZGVyLXByb2Nlc3MtZ3JhcGgvb3JkZXItcHJvY2Vzcy1ncmFwaC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUgsdUJBQXVCLEVBRXZCLFNBQVMsRUFDVCxXQUFXLEVBQ1gsS0FBSyxFQUtMLFlBQVksR0FDZixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsZUFBZSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUU5QyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzFDLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDOzs7OztBQVMzRSxNQUFNLE9BQU8sMEJBQTBCO0lBVW5DLFlBQW9CLGNBQWlDO1FBQWpDLG1CQUFjLEdBQWQsY0FBYyxDQUFtQjtRQVByRCxvQkFBZSxHQUFHLElBQUksZUFBZSxDQUFxQixTQUFTLENBQUMsQ0FBQztRQUVyRSxVQUFLLEdBQWdCLEVBQUUsQ0FBQztRQUN4QixVQUFLLEdBQTZGLEVBQUUsQ0FBQztJQUk3QyxDQUFDO0lBRXpELElBQ0ksV0FBVztRQUNYLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsV0FBVyxDQUFDO0lBQzNDLENBQUM7SUFFRCxRQUFRO1FBQ0osSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQzdDLElB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LENBQUMsQ0FBQztvQkFDSCxLQUFLLEVBQUUsQ0FBQztnQkFDWixDQUFDO1lBQ0wsQ0FBQztRQUNMLENBQUM7UUFDRCxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0IsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN2QyxDQUFDOzhHQW5GUSwwQkFBMEI7a0dBQTFCLDBCQUEwQiwrTkFRckIseUJBQXlCLHFFQ25DM0MsNmhCQVlBOzsyRkRlYSwwQkFBMEI7a0JBTnRDLFNBQVM7K0JBQ0kseUJBQXlCLG1CQUdsQix1QkFBdUIsQ0FBQyxNQUFNO3NGQUd0QyxNQUFNO3NCQUFkLEtBQUs7Z0JBQ0csWUFBWTtzQkFBcEIsS0FBSztnQkFNbUMsY0FBYztzQkFBdEQsWUFBWTt1QkFBQyx5QkFBeUI7Z0JBS25DLFdBQVc7c0JBRGQsV0FBVzt1QkFBQyxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gICAgQWZ0ZXJWaWV3SW5pdCxcclxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICBDb21wb25lbnQsXHJcbiAgICBIb3N0QmluZGluZyxcclxuICAgIElucHV0LFxyXG4gICAgT25DaGFuZ2VzLFxyXG4gICAgT25Jbml0LFxyXG4gICAgUXVlcnlMaXN0LFxyXG4gICAgU2ltcGxlQ2hhbmdlcyxcclxuICAgIFZpZXdDaGlsZHJlbixcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT3JkZXJQcm9jZXNzU3RhdGUgfSBmcm9tICdAdmVuZHVyZS9hZG1pbi11aS9jb3JlJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbmltcG9ydCB7IE5PREVfSEVJR0hUIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgeyBPcmRlclByb2Nlc3NOb2RlQ29tcG9uZW50IH0gZnJvbSAnLi9vcmRlci1wcm9jZXNzLW5vZGUuY29tcG9uZW50JztcclxuaW1wb3J0IHsgU3RhdGVOb2RlIH0gZnJvbSAnLi90eXBlcyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndmRyLW9yZGVyLXByb2Nlc3MtZ3JhcGgnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL29yZGVyLXByb2Nlc3MtZ3JhcGguY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgc3R5bGVVcmxzOiBbJy4vb3JkZXItcHJvY2Vzcy1ncmFwaC5jb21wb25lbnQuc2NzcyddLFxyXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBPcmRlclByb2Nlc3NHcmFwaENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0IHtcclxuICAgIEBJbnB1dCgpIHN0YXRlczogT3JkZXJQcm9jZXNzU3RhdGVbXTtcclxuICAgIEBJbnB1dCgpIGluaXRpYWxTdGF0ZT86IHN0cmluZztcclxuICAgIHNldEFjdGl2ZVN0YXRlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG4gICAgYWN0aXZlU3RhdGUkOiBPYnNlcnZhYmxlPHN0cmluZyB8IHVuZGVmaW5lZD47XHJcbiAgICBub2RlczogU3RhdGVOb2RlW10gPSBbXTtcclxuICAgIGVkZ2VzOiBBcnJheTx7IGZyb206IE9yZGVyUHJvY2Vzc05vZGVDb21wb25lbnQ7IHRvOiBPcmRlclByb2Nlc3NOb2RlQ29tcG9uZW50OyBpbmRleDogbnVtYmVyIH0+ID0gW107XHJcblxyXG4gICAgQFZpZXdDaGlsZHJlbihPcmRlclByb2Nlc3NOb2RlQ29tcG9uZW50KSBub2RlQ29tcG9uZW50czogUXVlcnlMaXN0PE9yZGVyUHJvY2Vzc05vZGVDb21wb25lbnQ+O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmKSB7fVxyXG5cclxuICAgIEBIb3N0QmluZGluZygnc3R5bGUuaGVpZ2h0LnB4JylcclxuICAgIGdldCBvdXRlckhlaWdodCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aCAqIE5PREVfSEVJR0hUO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIHRoaXMuc2V0QWN0aXZlU3RhdGUkLm5leHQodGhpcy5pbml0aWFsU3RhdGUpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlU3RhdGUkID0gdGhpcy5zZXRBY3RpdmVTdGF0ZSQucGlwZShkZWJvdW5jZVRpbWUoMTUwKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMucG9wdWxhdGVOb2RlcygpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucG9wdWxhdGVFZGdlcygpKTtcclxuICAgIH1cclxuXHJcbiAgICBvbk1vdXNlT3ZlcihzdGF0ZU5hbWU6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuc2V0QWN0aXZlU3RhdGUkLm5leHQoc3RhdGVOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBvbk1vdXNlT3V0KCkge1xyXG4gICAgICAgIHRoaXMuc2V0QWN0aXZlU3RhdGUkLm5leHQodGhpcy5pbml0aWFsU3RhdGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE5vZGVGb3Ioc3RhdGU6IHN0cmluZyk6IE9yZGVyUHJvY2Vzc05vZGVDb21wb25lbnQgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGlmICh0aGlzLm5vZGVDb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVDb21wb25lbnRzLmZpbmQoKG4pID0+IG4ubm9kZS5uYW1lID09PSBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcG9wdWxhdGVOb2RlcygpIHtcclxuICAgICAgICBjb25zdCBzdGF0ZU5vZGVNYXAgPSBuZXcgTWFwPHN0cmluZywgU3RhdGVOb2RlPigpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3RhdGUgb2YgdGhpcy5zdGF0ZXMpIHtcclxuICAgICAgICAgICAgc3RhdGVOb2RlTWFwLnNldChzdGF0ZS5uYW1lLCB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBzdGF0ZS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgdG86IFtdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHN0YXRlTm9kZV0gb2Ygc3RhdGVOb2RlTWFwLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0YXJnZXRzID0gdGhpcy5zdGF0ZXMuZmluZCgocykgPT4gcy5uYW1lID09PSBuYW1lKT8udG8gPz8gW107XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBzdGF0ZU5vZGVNYXAuZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlTm9kZS50by5wdXNoKHRhcmdldE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubm9kZXMgPSBbLi4uc3RhdGVOb2RlTWFwLnZhbHVlcygpXS5maWx0ZXIoKG4pID0+IG4ubmFtZSAhPT0gJ0NhbmNlbGxlZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcG9wdWxhdGVFZGdlcygpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5ub2Rlcykge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlQ21wID0gdGhpcy5nZXROb2RlRm9yKG5vZGUubmFtZSk7XHJcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG8gb2Ygbm9kZS50bykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9DbXAgPSB0aGlzLmdldE5vZGVGb3IodG8ubmFtZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZUNtcCAmJiB0b0NtcCAmJiBub2RlQ21wICE9PSB0b0NtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRnZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0b0NtcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogbm9kZUNtcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVkZ2VzID0gWy4uLnRoaXMuZWRnZXNdO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9XHJcbn1cclxuIiwiPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgc3RhdGUgb2Ygbm9kZXM7IGxldCBpID0gaW5kZXhcIj5cclxuICAgIDx2ZHItb3JkZXItcHJvY2Vzcy1ub2RlXHJcbiAgICAgICAgW25vZGVdPVwic3RhdGVcIlxyXG4gICAgICAgIFtpbmRleF09XCJpXCJcclxuICAgICAgICBbYWN0aXZlXT1cIihhY3RpdmVTdGF0ZSQgfCBhc3luYykgPT09IHN0YXRlLm5hbWVcIlxyXG4gICAgICAgIChtb3VzZWVudGVyKT1cIm9uTW91c2VPdmVyKHN0YXRlLm5hbWUpXCJcclxuICAgICAgICAobW91c2VsZWF2ZSk9XCJvbk1vdXNlT3V0KClcIlxyXG4gICAgPjwvdmRyLW9yZGVyLXByb2Nlc3Mtbm9kZT5cclxuPC9uZy1jb250YWluZXI+XHJcbjxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGVkZ2Ugb2YgZWRnZXNcIj5cclxuICAgIDx2ZHItb3JkZXItcHJvY2Vzcy1lZGdlIFtmcm9tXT1cImVkZ2UuZnJvbVwiIFt0b109XCJlZGdlLnRvXCIgW2luZGV4XT1cImVkZ2UuaW5kZXhcIj48L3Zkci1vcmRlci1wcm9jZXNzLWVkZ2U+XHJcbjwvbmctY29udGFpbmVyPlxyXG4iXX0=