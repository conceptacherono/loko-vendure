import { ChangeDetectionStrategy, Component, Input, } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { NODE_HEIGHT } from './constants';
import * as i0 from "@angular/core";
import * as i1 from "@clr/angular";
import * as i2 from "@angular/common";
import * as i3 from "@ngx-translate/core";
import * as i4 from "@vendure/admin-ui/core";
export class OrderProcessNodeComponent {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.active$ = new BehaviorSubject(false);
        this.activeTarget$ = new BehaviorSubject(false);
        this.isCancellable = false;
        // We use a class field here to prevent the
        // i18n extractor from extracting a "Cancelled" key
        this.cancelledState = 'Cancelled';
    }
    ngOnChanges(changes) {
        this.isCancellable = !!this.node.to.find((s) => s.name === 'Cancelled');
        if (changes.active) {
            this.active$.next(this.active);
        }
    }
    getPos(origin = 'top') {
        const rect = this.elementRef.nativeElement.getBoundingClientRect();
        const nodeHeight = this.elementRef.nativeElement.querySelector('.node')?.getBoundingClientRect().height ?? 0;
        return {
            x: 10,
            y: this.index * NODE_HEIGHT + (origin === 'bottom' ? nodeHeight : 0),
        };
    }
    getStyle() {
        const pos = this.getPos();
        return {
            'top.px': pos.y,
            'left.px': pos.x,
        };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: OrderProcessNodeComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.4", type: OrderProcessNodeComponent, selector: "vdr-order-process-node", inputs: { node: "node", index: "index", active: "active" }, usesOnChanges: true, ngImport: i0, template: "<div class=\"node-wrapper\" [ngStyle]=\"getStyle()\" [class.active]=\"active$ | async\">\r\n    <div\r\n        class=\"node\"\r\n        [class.active-target]=\"activeTarget$ | async\"\r\n    >\r\n        {{ node.name | stateI18nToken | translate }}\r\n    </div>\r\n    <div class=\"cancelled-wrapper\" *ngIf=\"isCancellable\">\r\n        <div class=\"cancelled-edge\">\r\n        </div>\r\n        <clr-icon shape=\"dot-circle\"></clr-icon>\r\n        <div class=\"cancelled-node\">\r\n            {{ cancelledState | stateI18nToken | translate }}\r\n        </div>\r\n    </div>\r\n</div>\r\n", styles: [":host{display:block}.node-wrapper{position:absolute;z-index:1;display:flex;align-items:center}.node{display:inline-block;border:2px solid var(--color-component-border-200);border-radius:3px;padding:3px 6px;z-index:1;background-color:var(--color-component-bg-100);opacity:.7;transition:opacity .2s,background-color .2s,color .2s;cursor:default}.node.active-target{border-color:var(--color-primary-500);opacity:.9}.cancelled-wrapper{display:flex;align-items:center;color:var(--color-grey-300);transition:color .2s,opacity .2s;opacity:.7}.cancelled-edge{width:48px;height:2px;background-color:var(--color-component-bg-300);transition:background-color .2s}clr-icon{margin-inline-start:-1px}.cancelled-node{margin-inline-start:6px}.active .cancelled-wrapper{opacity:1}.active .node{opacity:1;background-color:var(--color-primary-600);border-color:var(--color-primary-600);color:var(--color-primary-100)}.active .cancelled-wrapper{color:var(--color-error-500)}.active .cancelled-edge{background-color:var(--color-error-500)}\n"], dependencies: [{ kind: "directive", type: i1.ClrIconCustomTag, selector: "clr-icon" }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "pipe", type: i2.AsyncPipe, name: "async" }, { kind: "pipe", type: i3.TranslatePipe, name: "translate" }, { kind: "pipe", type: i4.StateI18nTokenPipe, name: "stateI18nToken" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: OrderProcessNodeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-order-process-node', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"node-wrapper\" [ngStyle]=\"getStyle()\" [class.active]=\"active$ | async\">\r\n    <div\r\n        class=\"node\"\r\n        [class.active-target]=\"activeTarget$ | async\"\r\n    >\r\n        {{ node.name | stateI18nToken | translate }}\r\n    </div>\r\n    <div class=\"cancelled-wrapper\" *ngIf=\"isCancellable\">\r\n        <div class=\"cancelled-edge\">\r\n        </div>\r\n        <clr-icon shape=\"dot-circle\"></clr-icon>\r\n        <div class=\"cancelled-node\">\r\n            {{ cancelledState | stateI18nToken | translate }}\r\n        </div>\r\n    </div>\r\n</div>\r\n", styles: [":host{display:block}.node-wrapper{position:absolute;z-index:1;display:flex;align-items:center}.node{display:inline-block;border:2px solid var(--color-component-border-200);border-radius:3px;padding:3px 6px;z-index:1;background-color:var(--color-component-bg-100);opacity:.7;transition:opacity .2s,background-color .2s,color .2s;cursor:default}.node.active-target{border-color:var(--color-primary-500);opacity:.9}.cancelled-wrapper{display:flex;align-items:center;color:var(--color-grey-300);transition:color .2s,opacity .2s;opacity:.7}.cancelled-edge{width:48px;height:2px;background-color:var(--color-component-bg-300);transition:background-color .2s}clr-icon{margin-inline-start:-1px}.cancelled-node{margin-inline-start:6px}.active .cancelled-wrapper{opacity:1}.active .node{opacity:1;background-color:var(--color-primary-600);border-color:var(--color-primary-600);color:var(--color-primary-100)}.active .cancelled-wrapper{color:var(--color-error-500)}.active .cancelled-edge{background-color:var(--color-error-500)}\n"] }]
        }], ctorParameters: () => [{ type: i0.ElementRef }], propDecorators: { node: [{
                type: Input
            }], index: [{
                type: Input
            }], active: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3JkZXItcHJvY2Vzcy1ub2RlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvb3JkZXIvc3JjL2NvbXBvbmVudHMvb3JkZXItcHJvY2Vzcy1ncmFwaC9vcmRlci1wcm9jZXNzLW5vZGUuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vc3JjL2xpYi9vcmRlci9zcmMvY29tcG9uZW50cy9vcmRlci1wcm9jZXNzLWdyYXBoL29yZGVyLXByb2Nlc3Mtbm9kZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0gsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFFVCxLQUFLLEdBR1IsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUV2QyxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sYUFBYSxDQUFDOzs7Ozs7QUFTMUMsTUFBTSxPQUFPLHlCQUF5QjtJQVdsQyxZQUFvQixVQUFzQztRQUF0QyxlQUFVLEdBQVYsVUFBVSxDQUE0QjtRQVAxRCxZQUFPLEdBQUcsSUFBSSxlQUFlLENBQVUsS0FBSyxDQUFDLENBQUM7UUFDOUMsa0JBQWEsR0FBRyxJQUFJLGVBQWUsQ0FBVSxLQUFLLENBQUMsQ0FBQztRQUNwRCxrQkFBYSxHQUFHLEtBQUssQ0FBQztRQUN0QiwyQ0FBMkM7UUFDM0MsbURBQW1EO1FBQ25ELG1CQUFjLEdBQUcsV0FBVyxDQUFDO0lBRWdDLENBQUM7SUFFOUQsV0FBVyxDQUFDLE9BQXNCO1FBQzlCLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxXQUFXLENBQUMsQ0FBQztRQUN4RSxJQUFJLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNqQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkMsQ0FBQztJQUNMLENBQUM7SUFFRCxNQUFNLENBQUMsU0FBMkIsS0FBSztRQUNuQyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1FBQ25FLE1BQU0sVUFBVSxHQUNaLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsRUFBRSxxQkFBcUIsRUFBRSxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUM7UUFDOUYsT0FBTztZQUNILENBQUMsRUFBRSxFQUFFO1lBQ0wsQ0FBQyxFQUFFLElBQUksQ0FBQyxLQUFLLEdBQUcsV0FBVyxHQUFHLENBQUMsTUFBTSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdkUsQ0FBQztJQUNOLENBQUM7SUFFRCxRQUFRO1FBQ0osTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzFCLE9BQU87WUFDSCxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDZixTQUFTLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDbkIsQ0FBQztJQUNOLENBQUM7OEdBcENRLHlCQUF5QjtrR0FBekIseUJBQXlCLCtJQ25CdEMsc2xCQWdCQTs7MkZER2EseUJBQXlCO2tCQU5yQyxTQUFTOytCQUNJLHdCQUF3QixtQkFHakIsdUJBQXVCLENBQUMsTUFBTTsrRUFHdEMsSUFBSTtzQkFBWixLQUFLO2dCQUNHLEtBQUs7c0JBQWIsS0FBSztnQkFDRyxNQUFNO3NCQUFkLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXHJcbiAgICBDb21wb25lbnQsXHJcbiAgICBFbGVtZW50UmVmLFxyXG4gICAgSW5wdXQsXHJcbiAgICBPbkNoYW5nZXMsXHJcbiAgICBTaW1wbGVDaGFuZ2VzLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuXHJcbmltcG9ydCB7IE5PREVfSEVJR0hUIH0gZnJvbSAnLi9jb25zdGFudHMnO1xyXG5pbXBvcnQgeyBTdGF0ZU5vZGUgfSBmcm9tICcuL3R5cGVzJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd2ZHItb3JkZXItcHJvY2Vzcy1ub2RlJyxcclxuICAgIHRlbXBsYXRlVXJsOiAnLi9vcmRlci1wcm9jZXNzLW5vZGUuY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgc3R5bGVVcmxzOiBbJy4vb3JkZXItcHJvY2Vzcy1ub2RlLmNvbXBvbmVudC5zY3NzJ10sXHJcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxufSlcclxuZXhwb3J0IGNsYXNzIE9yZGVyUHJvY2Vzc05vZGVDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xyXG4gICAgQElucHV0KCkgbm9kZTogU3RhdGVOb2RlO1xyXG4gICAgQElucHV0KCkgaW5kZXg6IG51bWJlcjtcclxuICAgIEBJbnB1dCgpIGFjdGl2ZTogYm9vbGVhbjtcclxuICAgIGFjdGl2ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcclxuICAgIGFjdGl2ZVRhcmdldCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcclxuICAgIGlzQ2FuY2VsbGFibGUgPSBmYWxzZTtcclxuICAgIC8vIFdlIHVzZSBhIGNsYXNzIGZpZWxkIGhlcmUgdG8gcHJldmVudCB0aGVcclxuICAgIC8vIGkxOG4gZXh0cmFjdG9yIGZyb20gZXh0cmFjdGluZyBhIFwiQ2FuY2VsbGVkXCIga2V5XHJcbiAgICBjYW5jZWxsZWRTdGF0ZSA9ICdDYW5jZWxsZWQnO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZjxIVE1MRGl2RWxlbWVudD4pIHt9XHJcblxyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgICAgIHRoaXMuaXNDYW5jZWxsYWJsZSA9ICEhdGhpcy5ub2RlLnRvLmZpbmQoKHMpID0+IHMubmFtZSA9PT0gJ0NhbmNlbGxlZCcpO1xyXG4gICAgICAgIGlmIChjaGFuZ2VzLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSQubmV4dCh0aGlzLmFjdGl2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGdldFBvcyhvcmlnaW46ICd0b3AnIHwgJ2JvdHRvbScgPSAndG9wJyk6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB7XHJcbiAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGNvbnN0IG5vZGVIZWlnaHQgPVxyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubm9kZScpPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgPz8gMDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiAxMCxcclxuICAgICAgICAgICAgeTogdGhpcy5pbmRleCAqIE5PREVfSEVJR0hUICsgKG9yaWdpbiA9PT0gJ2JvdHRvbScgPyBub2RlSGVpZ2h0IDogMCksXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBnZXRTdHlsZSgpIHtcclxuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmdldFBvcygpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICd0b3AucHgnOiBwb3MueSxcclxuICAgICAgICAgICAgJ2xlZnQucHgnOiBwb3MueCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbiIsIjxkaXYgY2xhc3M9XCJub2RlLXdyYXBwZXJcIiBbbmdTdHlsZV09XCJnZXRTdHlsZSgpXCIgW2NsYXNzLmFjdGl2ZV09XCJhY3RpdmUkIHwgYXN5bmNcIj5cclxuICAgIDxkaXZcclxuICAgICAgICBjbGFzcz1cIm5vZGVcIlxyXG4gICAgICAgIFtjbGFzcy5hY3RpdmUtdGFyZ2V0XT1cImFjdGl2ZVRhcmdldCQgfCBhc3luY1wiXHJcbiAgICA+XHJcbiAgICAgICAge3sgbm9kZS5uYW1lIHwgc3RhdGVJMThuVG9rZW4gfCB0cmFuc2xhdGUgfX1cclxuICAgIDwvZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cImNhbmNlbGxlZC13cmFwcGVyXCIgKm5nSWY9XCJpc0NhbmNlbGxhYmxlXCI+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNhbmNlbGxlZC1lZGdlXCI+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGNsci1pY29uIHNoYXBlPVwiZG90LWNpcmNsZVwiPjwvY2xyLWljb24+XHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImNhbmNlbGxlZC1ub2RlXCI+XHJcbiAgICAgICAgICAgIHt7IGNhbmNlbGxlZFN0YXRlIHwgc3RhdGVJMThuVG9rZW4gfCB0cmFuc2xhdGUgfX1cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG48L2Rpdj5cclxuIl19