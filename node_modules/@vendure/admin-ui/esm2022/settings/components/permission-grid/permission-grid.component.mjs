import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
import * as i2 from "@vendure/admin-ui/core";
import * as i3 from "@ngx-translate/core";
/**
 * A table showing and allowing the setting of all possible CRUD permissions.
 */
export class PermissionGridComponent {
    constructor() {
        this.readonly = false;
        this.permissionChange = new EventEmitter();
    }
    ngOnInit() {
        this.buildGrid();
    }
    setPermission(permission, value) {
        if (!this.readonly) {
            this.permissionChange.emit({ permission, value });
        }
    }
    toggleAll(defs) {
        const value = defs.some(d => !this.activePermissions.includes(d.name));
        for (const def of defs) {
            this.permissionChange.emit({ permission: def.name, value });
        }
    }
    buildGrid() {
        const crudGroups = new Map();
        const nonCrud = [];
        const crudRe = /^(Create|Read|Update|Delete)([a-zA-Z]+)$/;
        for (const def of this.permissionDefinitions) {
            const isCrud = crudRe.test(def.name);
            if (isCrud) {
                const groupName = def.name.match(crudRe)?.[2];
                if (groupName) {
                    const existing = crudGroups.get(groupName);
                    if (existing) {
                        existing.push(def);
                    }
                    else {
                        crudGroups.set(groupName, [def]);
                    }
                }
            }
            else if (def.assignable) {
                nonCrud.push(def);
            }
        }
        this.gridData = [
            ...nonCrud.map(d => ({
                label: d.name,
                description: d.description,
                permissions: [d],
            })),
            ...Array.from(crudGroups.entries()).map(([label, defs]) => ({
                label,
                description: this.extractCrudDescription(defs[0]),
                permissions: defs,
            })),
        ];
    }
    extractCrudDescription(def) {
        return def.description.replace(/Grants permission to [\w]+/, 'Grants permissions on');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: PermissionGridComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.2.4", type: PermissionGridComponent, selector: "vdr-permission-grid", inputs: { permissionDefinitions: "permissionDefinitions", activePermissions: "activePermissions", readonly: "readonly" }, outputs: { permissionChange: "permissionChange" }, ngImport: i0, template: "<table class=\"table\">\r\n    <tbody>\r\n        <tr *ngFor=\"let section of gridData\">\r\n            <td class=\"permission-group left\">\r\n                <div><strong>{{ section.label | translate }}</strong></div>\r\n                <small>{{ section.description | translate }}</small><br>\r\n                <button *ngIf=\"1 < section.permissions.length && !readonly\" class=\"button-small\" (click)=\"toggleAll(section.permissions)\">\r\n                    {{ 'common.toggle-all' | translate }}\r\n                </button>\r\n            </td>\r\n            <td *ngFor=\"let permission of section.permissions\" [attr.colspan]=\"section.permissions.length === 1 ? 4 : 1\">\r\n                <vdr-select-toggle\r\n                    size=\"small\"\r\n                    [title]=\"permission.description\"\r\n                    [label]=\"permission.name\"\r\n                    [disabled]=\"readonly\"\r\n                    [selected]=\"activePermissions?.includes(permission.name)\"\r\n                    (selectedChange)=\"setPermission(permission.name, $event)\"\r\n                ></vdr-select-toggle>\r\n            </td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n", styles: [":host{display:block}td.permission-group{max-width:300px;background-color:var(--color-component-bg-200)}\n"], dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i2.SelectToggleComponent, selector: "vdr-select-toggle", inputs: ["size", "selected", "hiddenWhenOff", "disabled", "label"], outputs: ["selectedChange"] }, { kind: "pipe", type: i3.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.2.4", ngImport: i0, type: PermissionGridComponent, decorators: [{
            type: Component,
            args: [{ selector: 'vdr-permission-grid', changeDetection: ChangeDetectionStrategy.OnPush, template: "<table class=\"table\">\r\n    <tbody>\r\n        <tr *ngFor=\"let section of gridData\">\r\n            <td class=\"permission-group left\">\r\n                <div><strong>{{ section.label | translate }}</strong></div>\r\n                <small>{{ section.description | translate }}</small><br>\r\n                <button *ngIf=\"1 < section.permissions.length && !readonly\" class=\"button-small\" (click)=\"toggleAll(section.permissions)\">\r\n                    {{ 'common.toggle-all' | translate }}\r\n                </button>\r\n            </td>\r\n            <td *ngFor=\"let permission of section.permissions\" [attr.colspan]=\"section.permissions.length === 1 ? 4 : 1\">\r\n                <vdr-select-toggle\r\n                    size=\"small\"\r\n                    [title]=\"permission.description\"\r\n                    [label]=\"permission.name\"\r\n                    [disabled]=\"readonly\"\r\n                    [selected]=\"activePermissions?.includes(permission.name)\"\r\n                    (selectedChange)=\"setPermission(permission.name, $event)\"\r\n                ></vdr-select-toggle>\r\n            </td>\r\n        </tr>\r\n    </tbody>\r\n</table>\r\n", styles: [":host{display:block}td.permission-group{max-width:300px;background-color:var(--color-component-bg-200)}\n"] }]
        }], propDecorators: { permissionDefinitions: [{
                type: Input
            }], activePermissions: [{
                type: Input
            }], readonly: [{
                type: Input
            }], permissionChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVybWlzc2lvbi1ncmlkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvc2V0dGluZ3Mvc3JjL2NvbXBvbmVudHMvcGVybWlzc2lvbi1ncmlkL3Blcm1pc3Npb24tZ3JpZC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL3NldHRpbmdzL3NyYy9jb21wb25lbnRzL3Blcm1pc3Npb24tZ3JpZC9wZXJtaXNzaW9uLWdyaWQuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFVLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQzs7Ozs7QUFVeEc7O0dBRUc7QUFPSCxNQUFNLE9BQU8sdUJBQXVCO0lBTnBDO1FBU2EsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUNoQixxQkFBZ0IsR0FBRyxJQUFJLFlBQVksRUFBMEMsQ0FBQztLQXlEM0Y7SUF0REcsUUFBUTtRQUNKLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUNyQixDQUFDO0lBRUQsYUFBYSxDQUFDLFVBQWtCLEVBQUUsS0FBYztRQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2pCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUN0RCxDQUFDO0lBQ0wsQ0FBQztJQUVELFNBQVMsQ0FBQyxJQUE0QjtRQUNsQyxNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3ZFLEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7WUFDckIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxFQUFFLFVBQVUsRUFBRSxHQUFHLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7UUFDaEUsQ0FBQztJQUNMLENBQUM7SUFFTyxTQUFTO1FBQ2IsTUFBTSxVQUFVLEdBQUcsSUFBSSxHQUFHLEVBQWtDLENBQUM7UUFDN0QsTUFBTSxPQUFPLEdBQTJCLEVBQUUsQ0FBQztRQUMzQyxNQUFNLE1BQU0sR0FBRywwQ0FBMEMsQ0FBQztRQUMxRCxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1lBQzNDLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3JDLElBQUksTUFBTSxFQUFFLENBQUM7Z0JBQ1QsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDOUMsSUFBSSxTQUFTLEVBQUUsQ0FBQztvQkFDWixNQUFNLFFBQVEsR0FBRyxVQUFVLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO29CQUMzQyxJQUFJLFFBQVEsRUFBRSxDQUFDO3dCQUNYLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ3ZCLENBQUM7eUJBQU0sQ0FBQzt3QkFDSixVQUFVLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7b0JBQ3JDLENBQUM7Z0JBQ0wsQ0FBQztZQUNMLENBQUM7aUJBQU0sSUFBSSxHQUFHLENBQUMsVUFBVSxFQUFFLENBQUM7Z0JBQ3hCLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdEIsQ0FBQztRQUNMLENBQUM7UUFDRCxJQUFJLENBQUMsUUFBUSxHQUFHO1lBQ1osR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztnQkFDakIsS0FBSyxFQUFFLENBQUMsQ0FBQyxJQUFJO2dCQUNiLFdBQVcsRUFBRSxDQUFDLENBQUMsV0FBVztnQkFDMUIsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQ25CLENBQUMsQ0FBQztZQUNILEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztnQkFDcEQsS0FBSztnQkFDTCxXQUFXLEVBQUUsSUFBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDakQsV0FBVyxFQUFFLElBQUk7YUFDcEIsQ0FBQyxDQUFDO1NBQ1YsQ0FBQztJQUNOLENBQUM7SUFFTyxzQkFBc0IsQ0FBQyxHQUF5QjtRQUNwRCxPQUFPLEdBQUcsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLDRCQUE0QixFQUFFLHVCQUF1QixDQUFDLENBQUM7SUFDMUYsQ0FBQzs4R0E1RFEsdUJBQXVCO2tHQUF2Qix1QkFBdUIsd09DbkJwQywycUNBdUJBOzsyRkRKYSx1QkFBdUI7a0JBTm5DLFNBQVM7K0JBQ0kscUJBQXFCLG1CQUdkLHVCQUF1QixDQUFDLE1BQU07OEJBR3RDLHFCQUFxQjtzQkFBN0IsS0FBSztnQkFDRyxpQkFBaUI7c0JBQXpCLEtBQUs7Z0JBQ0csUUFBUTtzQkFBaEIsS0FBSztnQkFDSSxnQkFBZ0I7c0JBQXpCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBtYXJrZXIgYXMgXyB9IGZyb20gJ0BiaWVzYmplcmcvbmd4LXRyYW5zbGF0ZS1leHRyYWN0LW1hcmtlcic7XHJcbmltcG9ydCB7IFBlcm1pc3Npb25EZWZpbml0aW9uIH0gZnJvbSAnQHZlbmR1cmUvYWRtaW4tdWkvY29yZSc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBlcm1pc3Npb25HcmlkUm93IHtcclxuICAgIGxhYmVsOiBzdHJpbmc7XHJcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gICAgcGVybWlzc2lvbnM6IFBlcm1pc3Npb25EZWZpbml0aW9uW107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIHRhYmxlIHNob3dpbmcgYW5kIGFsbG93aW5nIHRoZSBzZXR0aW5nIG9mIGFsbCBwb3NzaWJsZSBDUlVEIHBlcm1pc3Npb25zLlxyXG4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3Zkci1wZXJtaXNzaW9uLWdyaWQnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL3Blcm1pc3Npb24tZ3JpZC5jb21wb25lbnQuaHRtbCcsXHJcbiAgICBzdHlsZVVybHM6IFsnLi9wZXJtaXNzaW9uLWdyaWQuY29tcG9uZW50LnNjc3MnXSxcclxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUGVybWlzc2lvbkdyaWRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xyXG4gICAgQElucHV0KCkgcGVybWlzc2lvbkRlZmluaXRpb25zOiBQZXJtaXNzaW9uRGVmaW5pdGlvbltdO1xyXG4gICAgQElucHV0KCkgYWN0aXZlUGVybWlzc2lvbnM6IHN0cmluZ1tdO1xyXG4gICAgQElucHV0KCkgcmVhZG9ubHkgPSBmYWxzZTtcclxuICAgIEBPdXRwdXQoKSBwZXJtaXNzaW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjx7IHBlcm1pc3Npb246IHN0cmluZzsgdmFsdWU6IGJvb2xlYW4gfT4oKTtcclxuICAgIGdyaWREYXRhOiBQZXJtaXNzaW9uR3JpZFJvd1tdO1xyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG4gICAgICAgIHRoaXMuYnVpbGRHcmlkKCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UGVybWlzc2lvbihwZXJtaXNzaW9uOiBzdHJpbmcsIHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlYWRvbmx5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNoYW5nZS5lbWl0KHsgcGVybWlzc2lvbiwgdmFsdWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRvZ2dsZUFsbChkZWZzOiBQZXJtaXNzaW9uRGVmaW5pdGlvbltdKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkZWZzLnNvbWUoZCA9PiAhdGhpcy5hY3RpdmVQZXJtaXNzaW9ucy5pbmNsdWRlcyhkLm5hbWUpKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNoYW5nZS5lbWl0KHsgcGVybWlzc2lvbjogZGVmLm5hbWUsIHZhbHVlIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGJ1aWxkR3JpZCgpIHtcclxuICAgICAgICBjb25zdCBjcnVkR3JvdXBzID0gbmV3IE1hcDxzdHJpbmcsIFBlcm1pc3Npb25EZWZpbml0aW9uW10+KCk7XHJcbiAgICAgICAgY29uc3Qgbm9uQ3J1ZDogUGVybWlzc2lvbkRlZmluaXRpb25bXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGNydWRSZSA9IC9eKENyZWF0ZXxSZWFkfFVwZGF0ZXxEZWxldGUpKFthLXpBLVpdKykkLztcclxuICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiB0aGlzLnBlcm1pc3Npb25EZWZpbml0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCBpc0NydWQgPSBjcnVkUmUudGVzdChkZWYubmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChpc0NydWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwTmFtZSA9IGRlZi5uYW1lLm1hdGNoKGNydWRSZSk/LlsyXTtcclxuICAgICAgICAgICAgICAgIGlmIChncm91cE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGNydWRHcm91cHMuZ2V0KGdyb3VwTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2goZGVmKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcnVkR3JvdXBzLnNldChncm91cE5hbWUsIFtkZWZdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVmLmFzc2lnbmFibGUpIHtcclxuICAgICAgICAgICAgICAgIG5vbkNydWQucHVzaChkZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ3JpZERhdGEgPSBbXHJcbiAgICAgICAgICAgIC4uLm5vbkNydWQubWFwKGQgPT4gKHtcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBkLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZC5kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiBbZF0sXHJcbiAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgLi4uQXJyYXkuZnJvbShjcnVkR3JvdXBzLmVudHJpZXMoKSkubWFwKChbbGFiZWwsIGRlZnNdKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmV4dHJhY3RDcnVkRGVzY3JpcHRpb24oZGVmc1swXSksXHJcbiAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IGRlZnMsXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgXTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGV4dHJhY3RDcnVkRGVzY3JpcHRpb24oZGVmOiBQZXJtaXNzaW9uRGVmaW5pdGlvbik6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIGRlZi5kZXNjcmlwdGlvbi5yZXBsYWNlKC9HcmFudHMgcGVybWlzc2lvbiB0byBbXFx3XSsvLCAnR3JhbnRzIHBlcm1pc3Npb25zIG9uJyk7XHJcbiAgICB9XHJcbn1cclxuIiwiPHRhYmxlIGNsYXNzPVwidGFibGVcIj5cclxuICAgIDx0Ym9keT5cclxuICAgICAgICA8dHIgKm5nRm9yPVwibGV0IHNlY3Rpb24gb2YgZ3JpZERhdGFcIj5cclxuICAgICAgICAgICAgPHRkIGNsYXNzPVwicGVybWlzc2lvbi1ncm91cCBsZWZ0XCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2PjxzdHJvbmc+e3sgc2VjdGlvbi5sYWJlbCB8IHRyYW5zbGF0ZSB9fTwvc3Ryb25nPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPHNtYWxsPnt7IHNlY3Rpb24uZGVzY3JpcHRpb24gfCB0cmFuc2xhdGUgfX08L3NtYWxsPjxicj5cclxuICAgICAgICAgICAgICAgIDxidXR0b24gKm5nSWY9XCIxIDwgc2VjdGlvbi5wZXJtaXNzaW9ucy5sZW5ndGggJiYgIXJlYWRvbmx5XCIgY2xhc3M9XCJidXR0b24tc21hbGxcIiAoY2xpY2spPVwidG9nZ2xlQWxsKHNlY3Rpb24ucGVybWlzc2lvbnMpXCI+XHJcbiAgICAgICAgICAgICAgICAgICAge3sgJ2NvbW1vbi50b2dnbGUtYWxsJyB8IHRyYW5zbGF0ZSB9fVxyXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICAgIDwvdGQ+XHJcbiAgICAgICAgICAgIDx0ZCAqbmdGb3I9XCJsZXQgcGVybWlzc2lvbiBvZiBzZWN0aW9uLnBlcm1pc3Npb25zXCIgW2F0dHIuY29sc3Bhbl09XCJzZWN0aW9uLnBlcm1pc3Npb25zLmxlbmd0aCA9PT0gMSA/IDQgOiAxXCI+XHJcbiAgICAgICAgICAgICAgICA8dmRyLXNlbGVjdC10b2dnbGVcclxuICAgICAgICAgICAgICAgICAgICBzaXplPVwic21hbGxcIlxyXG4gICAgICAgICAgICAgICAgICAgIFt0aXRsZV09XCJwZXJtaXNzaW9uLmRlc2NyaXB0aW9uXCJcclxuICAgICAgICAgICAgICAgICAgICBbbGFiZWxdPVwicGVybWlzc2lvbi5uYW1lXCJcclxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwicmVhZG9ubHlcIlxyXG4gICAgICAgICAgICAgICAgICAgIFtzZWxlY3RlZF09XCJhY3RpdmVQZXJtaXNzaW9ucz8uaW5jbHVkZXMocGVybWlzc2lvbi5uYW1lKVwiXHJcbiAgICAgICAgICAgICAgICAgICAgKHNlbGVjdGVkQ2hhbmdlKT1cInNldFBlcm1pc3Npb24ocGVybWlzc2lvbi5uYW1lLCAkZXZlbnQpXCJcclxuICAgICAgICAgICAgICAgID48L3Zkci1zZWxlY3QtdG9nZ2xlPlxyXG4gICAgICAgICAgICA8L3RkPlxyXG4gICAgICAgIDwvdHI+XHJcbiAgICA8L3Rib2R5PlxyXG48L3RhYmxlPlxyXG4iXX0=