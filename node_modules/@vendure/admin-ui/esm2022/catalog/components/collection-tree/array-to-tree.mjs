/**
 * Builds a tree from an array of nodes which have a parent.
 * Based on https://stackoverflow.com/a/31247960/772859, modified to preserve ordering.
 */
export function arrayToTree(nodes, currentState, expandedIds = []) {
    const topLevelNodes = [];
    const mappedArr = {};
    const currentStateMap = treeToMap(currentState);
    // First map the nodes of the array to an object -> create a hash table.
    for (const node of nodes) {
        mappedArr[node.id] = { ...node, children: [] };
    }
    for (const id of nodes.map(n => n.id)) {
        if (mappedArr.hasOwnProperty(id)) {
            const mappedElem = mappedArr[id];
            mappedElem.expanded = currentStateMap.get(id)?.expanded ?? expandedIds.includes(id);
            const parent = mappedElem.parent;
            if (!parent) {
                continue;
            }
            // If the element is not at the root level, add it to its parent array of children.
            const parentIsRoot = !mappedArr[parent.id];
            if (!parentIsRoot) {
                if (mappedArr[parent.id]) {
                    mappedArr[parent.id].children.push(mappedElem);
                }
                else {
                    mappedArr[parent.id] = { children: [mappedElem] };
                }
            }
            else {
                topLevelNodes.push(mappedElem);
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const rootId = topLevelNodes.length ? topLevelNodes[0].parent.id : undefined;
    return { id: rootId, children: topLevelNodes };
}
/**
 * Converts an existing tree (as generated by the arrayToTree function) into a flat
 * Map. This is used to persist certain states (e.g. `expanded`) when re-building the
 * tree.
 */
function treeToMap(tree) {
    const nodeMap = new Map();
    function visit(node) {
        nodeMap.set(node.id, node);
        node.children.forEach(visit);
    }
    if (tree) {
        visit(tree);
    }
    return nodeMap;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJyYXktdG8tdHJlZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9saWIvY2F0YWxvZy9zcmMvY29tcG9uZW50cy9jb2xsZWN0aW9uLXRyZWUvYXJyYXktdG8tdHJlZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFJQTs7O0dBR0c7QUFDSCxNQUFNLFVBQVUsV0FBVyxDQUN2QixLQUFVLEVBQ1YsWUFBMEIsRUFDMUIsY0FBd0IsRUFBRTtJQUUxQixNQUFNLGFBQWEsR0FBdUIsRUFBRSxDQUFDO0lBQzdDLE1BQU0sU0FBUyxHQUFrQyxFQUFFLENBQUM7SUFDcEQsTUFBTSxlQUFlLEdBQUcsU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBRWhELHdFQUF3RTtJQUN4RSxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQ3ZCLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxHQUFJLElBQVksRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFLENBQUM7SUFDNUQsQ0FBQztJQUVELEtBQUssTUFBTSxFQUFFLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1FBQ3BDLElBQUksU0FBUyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQy9CLE1BQU0sVUFBVSxHQUFHLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNqQyxVQUFVLENBQUMsUUFBUSxHQUFHLGVBQWUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsUUFBUSxJQUFJLFdBQVcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDcEYsTUFBTSxNQUFNLEdBQUcsVUFBVSxDQUFDLE1BQU0sQ0FBQztZQUNqQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ1YsU0FBUztZQUNiLENBQUM7WUFDRCxtRkFBbUY7WUFDbkYsTUFBTSxZQUFZLEdBQUcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQzNDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztnQkFDaEIsSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7b0JBQ3ZCLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDbkQsQ0FBQztxQkFBTSxDQUFDO29CQUNKLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxRQUFRLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBUyxDQUFDO2dCQUM3RCxDQUFDO1lBQ0wsQ0FBQztpQkFBTSxDQUFDO2dCQUNKLGFBQWEsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDbkMsQ0FBQztRQUNMLENBQUM7SUFDTCxDQUFDO0lBQ0Qsb0VBQW9FO0lBQ3BFLE1BQU0sTUFBTSxHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDOUUsT0FBTyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLGFBQWEsRUFBRSxDQUFDO0FBQ25ELENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBUyxTQUFTLENBQXNCLElBQWtCO0lBQ3RELE1BQU0sT0FBTyxHQUFHLElBQUksR0FBRyxFQUF1QixDQUFDO0lBQy9DLFNBQVMsS0FBSyxDQUFDLElBQWlCO1FBQzVCLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMzQixJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxDQUFDO0lBQ0QsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUNQLEtBQUssQ0FBQyxJQUFtQixDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUNELE9BQU8sT0FBTyxDQUFDO0FBQ25CLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdHlwZSBIYXNQYXJlbnQgPSB7IGlkOiBzdHJpbmc7IHBhcmVudD86IHsgaWQ6IHN0cmluZyB9IHwgbnVsbCB9O1xyXG5leHBvcnQgdHlwZSBUcmVlTm9kZTxUIGV4dGVuZHMgSGFzUGFyZW50PiA9IFQgJiB7IGNoaWxkcmVuOiBBcnJheTxUcmVlTm9kZTxUPj47IGV4cGFuZGVkOiBib29sZWFuIH07XHJcbmV4cG9ydCB0eXBlIFJvb3ROb2RlPFQgZXh0ZW5kcyBIYXNQYXJlbnQ+ID0geyBpZD86IHN0cmluZzsgY2hpbGRyZW46IEFycmF5PFRyZWVOb2RlPFQ+PiB9O1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIHRyZWUgZnJvbSBhbiBhcnJheSBvZiBub2RlcyB3aGljaCBoYXZlIGEgcGFyZW50LlxyXG4gKiBCYXNlZCBvbiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzEyNDc5NjAvNzcyODU5LCBtb2RpZmllZCB0byBwcmVzZXJ2ZSBvcmRlcmluZy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcnJheVRvVHJlZTxUIGV4dGVuZHMgSGFzUGFyZW50PihcclxuICAgIG5vZGVzOiBUW10sXHJcbiAgICBjdXJyZW50U3RhdGU/OiBSb290Tm9kZTxUPixcclxuICAgIGV4cGFuZGVkSWRzOiBzdHJpbmdbXSA9IFtdLFxyXG4pOiBSb290Tm9kZTxUPiB7XHJcbiAgICBjb25zdCB0b3BMZXZlbE5vZGVzOiBBcnJheTxUcmVlTm9kZTxUPj4gPSBbXTtcclxuICAgIGNvbnN0IG1hcHBlZEFycjogeyBbaWQ6IHN0cmluZ106IFRyZWVOb2RlPFQ+IH0gPSB7fTtcclxuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZU1hcCA9IHRyZWVUb01hcChjdXJyZW50U3RhdGUpO1xyXG5cclxuICAgIC8vIEZpcnN0IG1hcCB0aGUgbm9kZXMgb2YgdGhlIGFycmF5IHRvIGFuIG9iamVjdCAtPiBjcmVhdGUgYSBoYXNoIHRhYmxlLlxyXG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XHJcbiAgICAgICAgbWFwcGVkQXJyW25vZGUuaWRdID0geyAuLi4obm9kZSBhcyBhbnkpLCBjaGlsZHJlbjogW10gfTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGNvbnN0IGlkIG9mIG5vZGVzLm1hcChuID0+IG4uaWQpKSB7XHJcbiAgICAgICAgaWYgKG1hcHBlZEFyci5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcclxuICAgICAgICAgICAgY29uc3QgbWFwcGVkRWxlbSA9IG1hcHBlZEFycltpZF07XHJcbiAgICAgICAgICAgIG1hcHBlZEVsZW0uZXhwYW5kZWQgPSBjdXJyZW50U3RhdGVNYXAuZ2V0KGlkKT8uZXhwYW5kZWQgPz8gZXhwYW5kZWRJZHMuaW5jbHVkZXMoaWQpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBtYXBwZWRFbGVtLnBhcmVudDtcclxuICAgICAgICAgICAgaWYgKCFwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIG5vdCBhdCB0aGUgcm9vdCBsZXZlbCwgYWRkIGl0IHRvIGl0cyBwYXJlbnQgYXJyYXkgb2YgY2hpbGRyZW4uXHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudElzUm9vdCA9ICFtYXBwZWRBcnJbcGFyZW50LmlkXTtcclxuICAgICAgICAgICAgaWYgKCFwYXJlbnRJc1Jvb3QpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXBwZWRBcnJbcGFyZW50LmlkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcHBlZEFycltwYXJlbnQuaWRdLmNoaWxkcmVuLnB1c2gobWFwcGVkRWxlbSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hcHBlZEFycltwYXJlbnQuaWRdID0geyBjaGlsZHJlbjogW21hcHBlZEVsZW1dIH0gYXMgYW55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdG9wTGV2ZWxOb2Rlcy5wdXNoKG1hcHBlZEVsZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cclxuICAgIGNvbnN0IHJvb3RJZCA9IHRvcExldmVsTm9kZXMubGVuZ3RoID8gdG9wTGV2ZWxOb2Rlc1swXS5wYXJlbnQhLmlkIDogdW5kZWZpbmVkO1xyXG4gICAgcmV0dXJuIHsgaWQ6IHJvb3RJZCwgY2hpbGRyZW46IHRvcExldmVsTm9kZXMgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGFuIGV4aXN0aW5nIHRyZWUgKGFzIGdlbmVyYXRlZCBieSB0aGUgYXJyYXlUb1RyZWUgZnVuY3Rpb24pIGludG8gYSBmbGF0XHJcbiAqIE1hcC4gVGhpcyBpcyB1c2VkIHRvIHBlcnNpc3QgY2VydGFpbiBzdGF0ZXMgKGUuZy4gYGV4cGFuZGVkYCkgd2hlbiByZS1idWlsZGluZyB0aGVcclxuICogdHJlZS5cclxuICovXHJcbmZ1bmN0aW9uIHRyZWVUb01hcDxUIGV4dGVuZHMgSGFzUGFyZW50Pih0cmVlPzogUm9vdE5vZGU8VD4pOiBNYXA8c3RyaW5nLCBUcmVlTm9kZTxUPj4ge1xyXG4gICAgY29uc3Qgbm9kZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBUcmVlTm9kZTxUPj4oKTtcclxuICAgIGZ1bmN0aW9uIHZpc2l0KG5vZGU6IFRyZWVOb2RlPFQ+KSB7XHJcbiAgICAgICAgbm9kZU1hcC5zZXQobm9kZS5pZCwgbm9kZSk7XHJcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKHZpc2l0KTtcclxuICAgIH1cclxuICAgIGlmICh0cmVlKSB7XHJcbiAgICAgICAgdmlzaXQodHJlZSBhcyBUcmVlTm9kZTxUPik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZU1hcDtcclxufVxyXG4iXX0=