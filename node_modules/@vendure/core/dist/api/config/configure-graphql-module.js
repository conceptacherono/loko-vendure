"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configureGraphQLModule = configureGraphQLModule;
const apollo_1 = require("@nestjs/apollo");
const graphql_1 = require("@nestjs/graphql");
const graphql_2 = require("graphql");
const config_module_1 = require("../../config/config.module");
const config_service_1 = require("../../config/config.service");
const i18n_module_1 = require("../../i18n/i18n.module");
const i18n_service_1 = require("../../i18n/i18n.service");
const service_module_1 = require("../../service/service.module");
const api_internal_modules_1 = require("../api-internal-modules");
const custom_field_relation_resolver_service_1 = require("../common/custom-field-relation-resolver.service");
const id_codec_service_1 = require("../common/id-codec.service");
const asset_interceptor_plugin_1 = require("../middleware/asset-interceptor-plugin");
const id_codec_plugin_1 = require("../middleware/id-codec-plugin");
const translate_errors_plugin_1 = require("../middleware/translate-errors-plugin");
const generate_resolvers_1 = require("./generate-resolvers");
const get_final_vendure_schema_1 = require("./get-final-vendure-schema");
/**
 * Dynamically generates a GraphQLModule according to the given config options.
 */
function configureGraphQLModule(getOptions) {
    return graphql_1.GraphQLModule.forRootAsync({
        driver: apollo_1.ApolloDriver,
        useFactory: (configService, i18nService, idCodecService, typesLoader, customFieldRelationResolverService) => {
            return createGraphQLOptions(i18nService, configService, idCodecService, typesLoader, customFieldRelationResolverService, getOptions(configService));
        },
        inject: [
            config_service_1.ConfigService,
            i18n_service_1.I18nService,
            id_codec_service_1.IdCodecService,
            graphql_1.GraphQLTypesLoader,
            custom_field_relation_resolver_service_1.CustomFieldRelationResolverService,
        ],
        imports: [config_module_1.ConfigModule, i18n_module_1.I18nModule, api_internal_modules_1.ApiSharedModule, service_module_1.ServiceModule],
    });
}
async function createGraphQLOptions(i18nService, configService, idCodecService, typesLoader, customFieldRelationResolverService, options) {
    var _a, _b;
    const builtSchema = await buildSchemaForApi(options.apiType);
    const resolvers = await (0, generate_resolvers_1.generateResolvers)(configService, customFieldRelationResolverService, options.apiType, builtSchema);
    const apolloServerPlugins = [
        new translate_errors_plugin_1.TranslateErrorsPlugin(i18nService),
        new asset_interceptor_plugin_1.AssetInterceptorPlugin(configService),
        ...configService.apiOptions.apolloServerPlugins,
    ];
    // We only need to add the IdCodecPlugin if the user has configured
    // a non-default EntityIdStrategy. This is a performance optimization
    // that prevents unnecessary traversal of each response when no
    // actual encoding/decoding is taking place.
    if (!(0, get_final_vendure_schema_1.isUsingDefaultEntityIdStrategy)((_a = configService.entityOptions.entityIdStrategy) !== null && _a !== void 0 ? _a : configService.entityIdStrategy)) {
        apolloServerPlugins.unshift(new id_codec_plugin_1.IdCodecPlugin(idCodecService));
    }
    return {
        path: '/' + options.apiPath,
        typeDefs: (0, graphql_2.printSchema)(builtSchema),
        include: [options.resolverModule],
        inheritResolversFromInterfaces: true,
        fieldResolverEnhancers: ['guards'],
        resolvers,
        // We no longer rely on the upload facility bundled with Apollo Server, and instead
        // manually configure the graphql-upload package. See https://github.com/vendure-ecommerce/vendure/issues/396
        uploads: false,
        playground: options.playground,
        csrfPrevention: false,
        debug: options.debug || false,
        context: (req) => req,
        // This is handled by the Express cors plugin
        cors: false,
        plugins: apolloServerPlugins,
        validationRules: options.validationRules,
        introspection: (_b = configService.apiOptions.introspection) !== null && _b !== void 0 ? _b : true,
    };
    /**
     * Generates the server's GraphQL schema by combining:
     * 1. the default schema as defined in the source .graphql files specified by `typePaths`
     * 2. any custom fields defined in the config
     * 3. any schema extensions defined by plugins
     */
    async function buildSchemaForApi(apiType) {
        return (0, get_final_vendure_schema_1.getFinalVendureSchema)({
            config: configService,
            typePaths: options.typePaths,
            typesLoader,
            apiType,
        });
    }
}
//# sourceMappingURL=configure-graphql-module.js.map